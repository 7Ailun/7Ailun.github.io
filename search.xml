<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java基础</title>
      <link href="/2022/12/06/java/"/>
      <url>/2022/12/06/java/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>Java定义了位运算符，应用于整数类型(int)，长整型(long)，短整型(short)，字符型(char)，和字节型(byte)等类型。<br>位运算符作用在所有的位上，并且按位运算。假设a &#x3D; 60，b &#x3D; 13;它们的二进制格式表示将如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">0011</span> <span class="number">1100</span></span><br><span class="line">B = <span class="number">0000</span> <span class="number">1101</span></span><br><span class="line">-----------------</span><br><span class="line">A&amp;B = <span class="number">0000</span> <span class="number">1100</span></span><br><span class="line">A | B = <span class="number">0011</span> <span class="number">1101</span></span><br><span class="line">A ^ B = <span class="number">0011</span> <span class="number">0001</span></span><br><span class="line">~A= <span class="number">1100</span> <span class="number">0011</span></span><br></pre></td></tr></table></figure><p>下表列出了位运算符的基本运算，假设整数变量 A 的值为 60 和变量 B 的值为 13：</p><table><thead><tr><th align="left">操作符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">＆</td><td align="left">如果相对应位都是1，则结果为1，否则为0</td><td align="left">（A＆B），得到12，即0000 1100</td></tr><tr><td align="left">\</td><td align="left"></td><td align="left">如果相对应位都是 0，则结果为 0，否则为 1</td></tr><tr><td align="left">^</td><td align="left">如果相对应位值相同，则结果为0，否则为1</td><td align="left">（A ^ B）得到49，即 0011 0001</td></tr><tr><td align="left">〜</td><td align="left">按位取反运算符翻转操作数的每一位，即0变成1，1变成0。</td><td align="left">（〜A）得到-61，即1100 0011</td></tr><tr><td align="left">&lt;&lt;</td><td align="left">按位左移运算符。左操作数按位左移右操作数指定的位数。</td><td align="left">A &lt;&lt; 2得到240，即 1111 0000</td></tr><tr><td align="left">&gt;&gt;</td><td align="left">按位右移运算符。左操作数按位右移右操作数指定的位数。</td><td align="left">A &gt;&gt; 2得到15即 1111</td></tr><tr><td align="left">&gt;&gt;&gt;</td><td align="left">按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。</td><td align="left">A&gt;&gt;&gt;2得到15即0000 1111</td></tr></tbody></table><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>下面的简单示例程序演示了位运算符。复制并粘贴下面的Java程序并保存为Test.java文件，然后编译并运行这个程序：<br>Test.java 文件代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">60</span>; <span class="comment">/* 60 = 0011 1100 */</span> </span><br><span class="line">     <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">13</span>; <span class="comment">/* 13 = 0000 1101 */</span></span><br><span class="line">     <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">     c = a &amp; b;       <span class="comment">/* 12 = 0000 1100 */</span></span><br><span class="line">     System.out.println(<span class="string">&quot;a &amp; b = &quot;</span> + c );</span><br><span class="line"> </span><br><span class="line">     c = a | b;       <span class="comment">/* 61 = 0011 1101 */</span></span><br><span class="line">     System.out.println(<span class="string">&quot;a | b = &quot;</span> + c );</span><br><span class="line"> </span><br><span class="line">     c = a ^ b;       <span class="comment">/* 49 = 0011 0001 */</span></span><br><span class="line">     System.out.println(<span class="string">&quot;a ^ b = &quot;</span> + c );</span><br><span class="line"> </span><br><span class="line">     c = ~a;          <span class="comment">/*-61 = 1100 0011 */</span></span><br><span class="line">     System.out.println(<span class="string">&quot;~a = &quot;</span> + c );</span><br><span class="line"> </span><br><span class="line">     c = a &lt;&lt; <span class="number">2</span>;     <span class="comment">/* 240 = 1111 0000 */</span></span><br><span class="line">     System.out.println(<span class="string">&quot;a &lt;&lt; 2 = &quot;</span> + c );</span><br><span class="line"> </span><br><span class="line">     c = a &gt;&gt; <span class="number">2</span>;     <span class="comment">/* 15 = 1111 */</span></span><br><span class="line">     System.out.println(<span class="string">&quot;a &gt;&gt; 2  = &quot;</span> + c );</span><br><span class="line">  </span><br><span class="line">     c = a &gt;&gt;&gt; <span class="number">2</span>;     <span class="comment">/* 15 = 0000 1111 */</span></span><br><span class="line">     System.out.println(<span class="string">&quot;a &gt;&gt;&gt; 2 = &quot;</span> + c );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上示例编译运行结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a &amp; b = <span class="number">12</span></span><br><span class="line">a | b = <span class="number">61</span></span><br><span class="line">a ^ b = <span class="number">49</span></span><br><span class="line">~a = -<span class="number">61</span></span><br><span class="line">a &lt;&lt; <span class="number">2</span> = <span class="number">240</span></span><br><span class="line">a &gt;&gt; <span class="number">2</span>  = <span class="number">15</span></span><br><span class="line">a &gt;&gt;&gt; <span class="number">2</span> = <span class="number">15</span></span><br></pre></td></tr></table></figure><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>什么是多态，多态具体体现有哪些？<br><strong>多态：方法或对象具有多种形态，是OOP的第三大特征，是建立在封装和继承基础之上</strong></p><h4 id="多态具体体现："><a href="#多态具体体现：" class="headerlink" title="多态具体体现："></a>多态具体体现：</h4><ol><li><strong>方法多态</strong><ol><li><strong>重载体现多态</strong></li><li><strong>重写体现多态</strong></li></ol></li><li><strong>对象多态</strong><ol><li><strong>对象的编译类型和运行类型可以不一致，编译类型在定义时，就确定，不能变化</strong></li><li><strong>对象的运行类型是可以变化的，可以通过getClass（）来查看运行类型</strong></li><li><strong>编译类型看 &#x3D; 号的左边，运行类型看 &#x3D; 号右边</strong></li></ol></li></ol><h4 id="向上转型调用方法的规则如下："><a href="#向上转型调用方法的规则如下：" class="headerlink" title="向上转型调用方法的规则如下："></a>向上转型调用方法的规则如下：</h4><p><strong>（1）可以调用父类中的所有成员（需遵守访问权限）</strong><br><strong>（2）但是不能调用子类的特有的成员</strong><br><strong>（3）因为在编译阶段，能调用那些成员，是由编译类型决定的</strong><br><strong>（4）最终运行效果看子类（运行类型）的具体实现，即调用方法时，按照从子类（运行类型）开始查找方法</strong></p><h4 id="多态向下转型"><a href="#多态向下转型" class="headerlink" title="多态向下转型"></a>多态向下转型</h4><p><strong>（1）语法：子类类型   引用名&#x3D;（子类类型）父类引用；</strong><br><strong>（2）只能强转父类的引用，不能强转父类的对象</strong><br><strong>（3）要求父类的引用必须只想的是当前目标类型的对象</strong><br><strong>（4）向下转型后，可以调用子类类型中所有的成员</strong><br><img src="C:\Users\99301\AppData\Roaming\Typora\typora-user-images\image-20221101212452407.png" alt="image-20221101212452407"></p><h4 id="多态注意事项和细节讨论"><a href="#多态注意事项和细节讨论" class="headerlink" title="多态注意事项和细节讨论"></a>多态注意事项和细节讨论</h4><p>属性没有重写之说！属性的值看编译类型<br>instanceOf比较操作符，用于判断<strong>对象的运行类型</strong>是否为XX类型或XX类型的子类型</p><h4 id="x3D-x3D-和equals的区别"><a href="#x3D-x3D-和equals的区别" class="headerlink" title="&#x3D;&#x3D;和equals的区别"></a>&#x3D;&#x3D;和equals的区别</h4><p><img src="C:\Users\99301\AppData\Roaming\Typora\typora-user-images\image-20221101212801283.png"></p><h4 id="Java的动态绑定机制（巨重要）"><a href="#Java的动态绑定机制（巨重要）" class="headerlink" title="Java的动态绑定机制（巨重要）"></a>Java的动态绑定机制（巨重要）</h4><ol><li>1.当调用对象方法的时候，该对象会和该对象的<strong>内存地址&#x2F;运行类型</strong>绑定<br>2.当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用</li></ol><h2 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a>hashCode方法</h2><ol><li>1.提高具有哈希结构的容器的效率！</li><li>2.两个引用，如果指向的是同一个对象，则哈希值肯定是一样的！</li><li>3.两个引用，如果指向的是不同对象，则哈希值是不一样的</li><li>4.哈希值主要根据地址号来的！，不能完全将哈希值等价于地址。</li></ol><h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h2><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>默认返回：全类名+@哈希值的十六进制，【查看Object 的 toString方法】子类往往重写toString方法，用于返回对象的属性信息<br>重写toString方法，打印对象或拼接对象时，都会自动调用该对象的toString形式<br>当直接输出一个对象是，toString方法会被默认的调用</p><h2 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h2><p>已废弃</p><h2 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h2><ul><li><strong>断掉调试的快捷键：</strong><br><strong>F7（跳入） F8（跳过） shift + F8（跳出） F9（resume，执行到下一个断点）</strong><br><strong>F7：跳入方法内</strong><br><strong>F8：逐行执行代码</strong><br> <strong>shift + F8：跳出方法</strong></li></ul><h2 id="理解main方法语法"><a href="#理解main方法语法" class="headerlink" title="理解main方法语法"></a>理解main方法语法</h2><p>解释main方法的形式：public static void main（String[] args）{}</p><ol><li><strong>main方法是虚拟机调用</strong></li><li><strong>java虚拟机需要调用类的main()方法，所以方法的访问权限必须是public</strong></li><li><strong>java虚拟机在执行main()方法时不必创建对象，所以该方法必须是static</strong></li><li><strong>该方法接收String 类型的数组参数，该数组中保存执行java命令时传递给所运行的类的参数</strong></li><li><strong>java 执行的程序 参数1 参数2 参数3 ……..</strong></li></ol><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><ol><li><strong>static代码块也叫静态代码块，作用就是对类进行初始化，而且它随着类的加载而执行，并且指挥执行一次。如果是普通代码块，每创建一个对象，就执行。</strong></li><li><strong>类什么时候被加载</strong><br><strong>1.创建对象实例时(new)</strong><br><strong>2.创建子类对象实例，父类也会被加载</strong><br><strong>3.使用类的静态成员时(静态属性，静态方法)</strong></li><li><strong>普通的代码块，在创建对象实例时，会被隐式的调用。</strong><br><strong>被创建一次，就会调用一次。</strong><br><strong>如果只是使用类的静态成员时，普通代码快不会执行。</strong><br><strong>小结</strong></li><li>static代码块时类加载时，执行，只会执行一次</li><li>普通代码快时在创建对象时调用的，创建一次，调用一次</li><li>类加载的3钟情况，需要记住<br><strong>创建一个对象时，在一个类 调用的顺序是：(重点、难点)</strong></li><li>调用静态代码块和静态属性初始化(注意：静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按他们定义的顺序调用)</li><li>调用普通代码块和普通属性的初始化(注意：普通代码和普通属性初始化调用的优先级一样，如果多个普通代码块和多个普通属性初始化，则按定义顺序调用)</li><li>调用构造方法<br><strong>Title:</strong><br><strong>构造器的最前面其实隐含了 super()和调用普通代码块，新写一个类演示（截图+说明）静态相关的代码块，属性初始化，在类加载时，就执行完毕，因此时优先于构造器和普通代码块执行的</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//这里有隐藏的执行要求</span></span><br><span class="line"><span class="comment">//（1）super();</span></span><br><span class="line"><span class="comment">//（2）调用普通代码块</span></span><br><span class="line">System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h2><p><strong>final 可以修饰类、属性、方法和局部变量</strong><br><strong>在某些情况下程序员可能有以下需求，就会用到final</strong></p><ol><li>当不希望被继承时，可以用final修饰</li><li>党部希望父类的某个方法被子类覆盖&#x2F;重写（override），可以用final关键字</li><li>当不希望类的某个属性的值被修改，可以用final修饰</li><li>当不希望某个局部变量被修改，可以使用final修饰<br><strong>final使用注意事项和细节</strong></li><li>final修饰的属性又叫常量，一般用XX_XX_XX离开命名</li><li>final修饰的属性在定义时，必须赋初值，并且以后不能再修改，赋值可以在如下位置之一【选择一个位置赋值即可】</li></ol><p>​①定义时：如public final double TAX_RATE &#x3D; 0.08；</p><p>​②在构造器中</p><p>​③在代码块中</p><p>​3.如果final修饰的属性时静态的，则初始化的位置只能是①定义时，②在静态代码块，不能在构造器中赋值。</p><p>​4.final类不能继承，但是可以实例化对象。</p><p>​5.如果不是final类，但是含有final方法，则该方法虽然不能重写，但是可以被继承。</p><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><h3 id="抽象类的介绍"><a href="#抽象类的介绍" class="headerlink" title="抽象类的介绍"></a>抽象类的介绍</h3><ol><li>用abstract 关键字来修饰一个类时，这个类就是抽象类<br>访问修饰符 abstract 类名{}</li><li>用abstract 关键字来修饰一个方法时，这个方法是抽象方法<br><strong>访问修饰符 abstract 返回类型 方法名（参数列表）；&#x2F;&#x2F;没有方法体</strong></li><li>抽象类的价值更多作用是在于设计，时设计者设计号后，让子类继承并实现抽象类（）</li><li>抽象类，时考官比较爱问的知识点，在框架和设计模式使用较多</li></ol><h3 id="抽象类使用细节和注意事项"><a href="#抽象类使用细节和注意事项" class="headerlink" title="抽象类使用细节和注意事项"></a>抽象类使用细节和注意事项</h3><ol><li>抽象类不能被实例化</li><li>抽象类不一定要包含abstract方法。也就是说，抽象类可以没有abstract方法</li><li>一旦类包含了abstract方法，则这个类必须声明为abstract</li><li>abstract只能修饰类和方法，不能修饰属性和其他的。</li><li>抽象类可以有任意成员【引文抽象类还是类】，比如：非抽象方法、构造器、静态属性等</li><li>抽象方法不能有主题，即不能实现 abstract void aaa（）{ }；</li><li>如果一个类继承了抽象类，则他必须实现抽象类的所有抽象方法，排除它自己也声明为abstract类</li></ol><h3 id="static和abstract为何不能同时出现"><a href="#static和abstract为何不能同时出现" class="headerlink" title="static和abstract为何不能同时出现"></a>static和abstract为何不能同时出现</h3><p>当我们试图使用abstract和static同时修饰一个方法时会发现编译器报错，原因在哪里呢？<br>因为static修饰的方法是静态方法，其可以直接被类所调用。而abstract修饰的方法为抽象方法，即无方法体的方法，不能够被直接调用，需要在子类或实现类中去编写完整的方法处理逻辑后才能使用。</p><h2 id="模板设计模式"><a href="#模板设计模式" class="headerlink" title="模板设计模式"></a>模板设计模式</h2><p>概念：<br>固定的流程已经写好了，变化的流程定义成了抽象方法，被子类重写。<br>模板设计就是一种编码风格，把抽象类看作是一个模板，模板中不能决定的东西定义成抽象方法，让使用模板的去重写抽象方法实现需求<br>简单来说：模板设计就是提前搭建好了一些<a href="https://so.csdn.net/so/search?q=%E6%A1%86%E6%9E%B6&spm=1001.2101.3001.7020">框架</a>，但是更细节的东西需要实现类再去实现<br><a href="https://so.csdn.net/so/search?q=%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F&spm=1001.2101.3001.7020">设计模式</a>（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。<br>使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。</p><p>模板设计模式：</p><p>把抽象类整体就可以看做成一个模板，模板中不能决定的东西定义成抽象方法，让使用模板的类（继承抽象类的类）去重写抽象方法实现需求，模板已经定义了通用结构，使用者只需要关心自己需要实现的功能即可</p><p>模板设计模式的优势：<br>1.只需要关注不同的流程，相同交给父类(模板类)去做。<br>2.解耦：各司其职，一个类只关注自己的事情</p><ul><li>模块化：是解耦这种思维的实现方法方式。</li><li>getter&#x2F;setter就是模块化</li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul><li>基本介绍</li></ul><p>接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，再根据具体情况把这些方法写出来。语法：</p><p>interface 接口名{</p><p>&#x2F;&#x2F;属性</p><p>&#x2F;&#x2F;方法（1.抽象方法 2.默认实现方法 3.静态方法）</p><p>}</p><ul><li>class 类名 implements 接口{</li></ul><p>自己属性；</p><p>自己方法；</p><p>必须实现的接口的抽象方法</p><p>}</p><p>小结：</p><ol><li>在jdk7.0前 接口里的所有方法都没有方法体，即都是抽象方法。</li><li>jdk8.0后接口可以有静态方法，默认方法，也就是说接口中可以有方法的具体实现</li></ol><ul><li><p>注意事项和细节</p><p>1.接口不能被实例化</p><p>2.接口中所有的方法时 public方法，接口中抽象方法，可以不用abstract修饰 图示：</p><p>void aaa();</p><p>实际上是： abstract void aaa();</p><p>3.一个普通类实现接口，就必须将改接口的所有方法都实现。</p><p>4.抽象类实现接口，可以不用实现接口的方法。</p></li></ul><p>​5.一个类同时可以实现多个接口</p><p>​6.接口中的属性，只能是final的，而且是 public static final 修饰符。</p><p>​比如：int a &#x3D; 1；实际上是public static final int a &#x3D; 1;(必须初始化)</p><p>​7.接口中的属性的访问形式：接口名.属性名</p><p>​8.接口不能继承其他的类，但是可以继承多个和别的接口</p><p>interface A extends B，C{}</p><p>​9.接口的修饰符只能是 public 和 默认，这点和类的修饰符是一样的。</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><h3 id="自定义枚举类"><a href="#自定义枚举类" class="headerlink" title="自定义枚举类"></a>自定义枚举类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tataki.main01.Enumeration;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 艾伦</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Enumeration01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//使用</span></span><br><span class="line">        System.out.println(Season.spring);</span><br><span class="line">        System.out.println(Season.summer);</span><br><span class="line">        System.out.println(Season.autumn);</span><br><span class="line">        System.out.println(Season.winter);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">    <span class="comment">//1.构造器私有</span></span><br><span class="line">    <span class="comment">//2.在本类创建一组对象</span></span><br><span class="line">    <span class="comment">//3.对外暴露对象（通过加public static final修饰）</span></span><br><span class="line">    <span class="comment">//4.可以提供get方法，但是不能提供set</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line">    <span class="comment">//public static final String num = &quot;19999&quot;; // 不会导致类加载</span></span><br><span class="line">    <span class="comment">//下面的还是会导致类加载，因为数据类型是Season，并不是普通数据类型比如：String int..</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">spring</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;温暖&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">winter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;东天&quot;</span>,<span class="string">&quot;寒冷&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">summer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;炎热&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">autumn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;凉爽&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String name, String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我又来了喔&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Season&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, desc=&#x27;&quot;</span> + desc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*此处小结</span></span><br><span class="line"><span class="comment">1.static final只有修饰基本数据，才不会造成类加载，其他Interger、对象或者方法还是会加载</span></span><br><span class="line"><span class="comment">2.final修饰对象（引用）只是保证指向不变，但不能保证对象本身b</span></span><br></pre></td></tr></table></figure><p><img src="C:\Users\99301\AppData\Roaming\Typora\typora-user-images\image-20221111211238533.png" alt="image-20221111211238533"></p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><ul><li><h4 id="基本介绍："><a href="#基本介绍：" class="headerlink" title="基本介绍："></a>基本介绍：</h4><ul><li>Collection实现子类可以存放多个元素，每个元素可以是Object</li><li>Collection的实现类，有些可以存放重复的元素，有些不可以</li><li>Collection的实现类，有些是有序的(List)，有些不是有序(Set)</li><li>Collection接口没有直接的实现子类，是通过它的子接口Set 和 List 来实现的</li></ul></li><li><h4 id="接口常用方法："><a href="#接口常用方法：" class="headerlink" title="接口常用方法："></a>接口常用方法：</h4><ul><li><p>add：添加单个元素</p></li><li><p>remove：删除指定元素</p></li><li><p>contains：查找元素是否存在</p></li><li><p>size：获取元素个数</p></li><li><p>isEmpty：判断是否为空</p></li><li><p>clear：清空</p></li><li><p>addAll：添加多个元素</p></li><li><p>containsAll：查找多个元素是否都存在</p></li><li><p>removeAll：删除多个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="comment">//        add:添加单个元素</span></span><br><span class="line">        list.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        list.add(<span class="number">10</span>);<span class="comment">//list.add(new Integer(10))</span></span><br><span class="line">        list.add(<span class="literal">true</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"><span class="comment">//        remove:删除指定元素</span></span><br><span class="line">        <span class="comment">//list.remove(0);//删除第一个元素</span></span><br><span class="line">        list.remove(<span class="literal">true</span>);<span class="comment">//指定删除某个元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"><span class="comment">//        contains:查找元素是否存在</span></span><br><span class="line">        System.out.println(list.contains(<span class="string">&quot;jack&quot;</span>));<span class="comment">//T</span></span><br><span class="line"><span class="comment">//        size:获取元素个数</span></span><br><span class="line">        System.out.println(list.size());<span class="comment">//2</span></span><br><span class="line"><span class="comment">//        isEmpty:判断是否为空</span></span><br><span class="line">        System.out.println(list.isEmpty());<span class="comment">//F</span></span><br><span class="line"><span class="comment">//        clear:清空</span></span><br><span class="line">        list.clear();</span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"><span class="comment">//        addAll:添加多个元素</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list2.add(<span class="string">&quot;红楼梦&quot;</span>);</span><br><span class="line">        list2.add(<span class="string">&quot;三国演义&quot;</span>);</span><br><span class="line">        list.addAll(list2);</span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"><span class="comment">//        containsAll:查找多个元素是否都存在</span></span><br><span class="line">        System.out.println(list.containsAll(list2));<span class="comment">//T</span></span><br><span class="line"><span class="comment">//        removeAll：删除多个元素</span></span><br><span class="line">        list.add(<span class="string">&quot;聊斋&quot;</span>);</span><br><span class="line">        list.removeAll(list2);</span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);<span class="comment">//[聊斋]</span></span><br><span class="line"><span class="comment">//        说明：以ArrayList实现类来演示.</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><ul><li><h4 id="基本介绍：-1"><a href="#基本介绍：-1" class="headerlink" title="基本介绍："></a>基本介绍：</h4><ul><li>List集合类中元素有序（即添加顺序和取出顺序一致）、且可重复</li><li>List集合中的每个元素都有其对应的顺序索引，即支持索引</li><li>List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器元素</li><li>常用： ArrayList、LinkedList、Vector</li></ul></li><li><h4 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a>常用方法：</h4><ul><li><p>void add(int index, Object ele)：在index位置插入ele元素</p></li><li><p>boolean addAll(int index, Collection eles)：从index位置开始将eles中的所有元素添加进来</p></li><li><p>Object get(int index)：获取指定index位置的元素</p></li><li><p>int indexOf(Object obj)：返回obj在集合中首次出现的位置</p></li><li><p>int lastindexOf(Object obj)：返回obj在当前集合中末次出现的位置</p></li><li><p>Object remove(int index)：移除指定index位置的元素，井返回此元素</p></li><li><p>Object set(int index, Object ele)：设置指定index位置的元素为ele，相当于是替换</p></li><li><p>List sublist(int fromlndex, int tolndex)：返回从fromlndex到tolndex位置的子集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list.add(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;贾宝玉&quot;</span>);</span><br><span class="line"><span class="comment">//        void add(int index, Object ele):在index位置插入ele元素</span></span><br><span class="line">        <span class="comment">//在index = 1的位置插入一个对象</span></span><br><span class="line">        list.add(<span class="number">1</span>, <span class="string">&quot;韩顺平&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list2.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        list2.add(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        list.addAll(<span class="number">1</span>, list2);</span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        Object get(int index):获取指定index位置的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        int indexOf(Object obj):返回obj在集合中首次出现的位置</span></span><br><span class="line">        System.out.println(list.indexOf(<span class="string">&quot;tom&quot;</span>));<span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置</span></span><br><span class="line">        list.add(<span class="string">&quot;韩顺平&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line">        System.out.println(list.lastIndexOf(<span class="string">&quot;韩顺平&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//        Object remove(int index):移除指定index位置的元素，并返回此元素</span></span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        Object set(int index, Object ele):设置指定index位置的元素为ele , 相当于是替换.</span></span><br><span class="line">        list.set(<span class="number">1</span>, <span class="string">&quot;玛丽&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合</span></span><br><span class="line">        <span class="comment">// 注意返回的子集合 fromIndex &lt;= subList &lt; toIndex</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">returnlist</span> <span class="operator">=</span> list.subList(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;returnlist=&quot;</span> + returnlist);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><ul><li><h4 id="基本介绍：-2"><a href="#基本介绍：-2" class="headerlink" title="基本介绍："></a>基本介绍：</h4><ul><li><p>lterator对象称为迭代器，主要用于遍历 Collection 集合中的元素</p></li><li><p>实现了Collection接口的集合都有一个iterator()方法，用以返回一个实现了lterator接口的对象，即可以返回一个迭代器</p></li><li><p>lterator 仅用于遍历集合，lterator 本身并不存放对象</p></li><li><p>在调用it.next()方法之前必须要调用it.hasNext()进行检测。若不调用，且下一条记录无效，直接调用it.next()会抛出NoSuchElementException异常</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3833/%E6%88%AA%E5%B1%8F2022-05-24%2017.23.58.jpg" alt="截屏2022-05-24 17.23.58"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionIterator</span> &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;all&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Collection</span> <span class="variable">col</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line">        col.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;三国演义&quot;</span>, <span class="string">&quot;罗贯中&quot;</span>, <span class="number">10.1</span>));</span><br><span class="line">        col.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;小李飞刀&quot;</span>, <span class="string">&quot;古龙&quot;</span>, <span class="number">5.1</span>));</span><br><span class="line">        col.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;红楼梦&quot;</span>, <span class="string">&quot;曹雪芹&quot;</span>, <span class="number">34.6</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println(&quot;col=&quot; + col);</span></span><br><span class="line">        <span class="comment">//现在老师希望能够遍历 col集合</span></span><br><span class="line">        <span class="comment">//1. 先得到 col 对应的 迭代器</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> col.iterator();</span><br><span class="line">        <span class="comment">//2. 使用while循环遍历</span></span><br><span class="line"><span class="comment">//        while (iterator.hasNext()) &#123;//判断是否还有数据</span></span><br><span class="line"><span class="comment">//            //返回下一个元素，类型是Object</span></span><br><span class="line"><span class="comment">//            Object obj = iterator.next();</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;obj=&quot; + obj);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment">//老师教大家一个快捷键，快速生成 while =&gt; itit</span></span><br><span class="line">        <span class="comment">//显示所有的快捷键的的快捷键 ctrl + j</span></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;obj=&quot;</span> + obj);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3. 当退出while循环后 , 这时iterator迭代器，指向最后的元素</span></span><br><span class="line">        <span class="comment">//   iterator.next();//NoSuchElementException</span></span><br><span class="line">        <span class="comment">//4. 如果希望再次遍历，需要重置我们的迭代器</span></span><br><span class="line">        iterator = col.iterator();</span><br><span class="line">        System.out.println(<span class="string">&quot;===第二次遍历===&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;obj=&quot;</span> + obj);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Book</span><span class="params">(String name, String author, <span class="type">double</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.author = author;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAuthor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAuthor</span><span class="params">(String author)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.author = author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(<span class="type">double</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Book&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, author=&#x27;&quot;</span> + author + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, price=&quot;</span> + price +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="for增强循环"><a href="#for增强循环" class="headerlink" title="for增强循环"></a>for增强循环</h4><ul><li><h4 id="基本介绍：-3"><a href="#基本介绍：-3" class="headerlink" title="基本介绍："></a>基本介绍：</h4><p>增强for循环，可以代替iterator迭代器，特点：增强for就是简化版的iterator，本质一样，只能用于遍历集合或数组</p></li><li><h4 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素类型 元素名: 集合名或数组名)&#123;</span><br><span class="line">  访问元素;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="普通遍历循环"><a href="#普通遍历循环" class="headerlink" title="普通遍历循环"></a>普通遍历循环</h4><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><ul><li><h4 id="注意事项和细节："><a href="#注意事项和细节：" class="headerlink" title="注意事项和细节："></a>注意事项和细节：</h4><ol><li>允许所有元素包括null加入</li><li>ArrayList 是由数组来实现数据存储的</li><li>ArrayList 基本等同于Vector，除了 ArrayList是线程不安全（执行效率高），在多线程情况下，不建议使用ArrayList</li></ol></li><li><h4 id="底层结构和源码分析："><a href="#底层结构和源码分析：" class="headerlink" title="底层结构和源码分析："></a>底层结构和源码分析：</h4><ol><li><p>ArrayList中维护了一个Object类型的数组elementData，transient Object[] elementData; </p><p>transient 表示瞬间,短暂的，表示该属性不会被序列化</p></li><li><p>创建ArrayList对象时，如果使用的是无参构造器，则初始elementData容量为0，第1次添加，则扩容elementData为10，如需要再次扩容，则扩容elementData 为1.5倍</p></li><li><p>如果使用的是指定大小的构造器，则初始elementData容量为指定大小，如果需要扩容，则直接扩容elementData为1.5倍</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3833/%E6%88%AA%E5%B1%8F2022-05-25%2011.38.41.jpg" alt="截屏2022-05-25 11.38.41"></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3833/%E6%88%AA%E5%B1%8F2022-05-25%2011.40.06.jpg" alt="截屏2022-05-25 11.40.06"></p></li></ol></li></ul><h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><ul><li><h4 id="注意事项和细节：-1"><a href="#注意事项和细节：-1" class="headerlink" title="注意事项和细节："></a>注意事项和细节：</h4><ol><li>Vector底层是一个对象数组， protected Object[] elementData;</li><li>Vector 是线程同步的，即线程安全，Vector类的操作方法带有synchronized</li></ol></li><li><h4 id="底层机制和源码分析："><a href="#底层机制和源码分析：" class="headerlink" title="底层机制和源码分析："></a>底层机制和源码分析：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Vector_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//无参构造器</span></span><br><span class="line">        <span class="comment">//有参数的构造</span></span><br><span class="line">        <span class="type">Vector</span> <span class="variable">vector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vector</span>(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            vector.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        vector.add(<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;vector=&quot;</span> + vector);</span><br><span class="line">        <span class="comment">//老韩解读源码</span></span><br><span class="line">        <span class="comment">//1. new Vector() 底层</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            public Vector() &#123;</span></span><br><span class="line"><span class="comment">                this(10);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">         补充：如果是  Vector vector = new Vector(8);</span></span><br><span class="line"><span class="comment">            走的方法:</span></span><br><span class="line"><span class="comment">            public Vector(int initialCapacity) &#123;</span></span><br><span class="line"><span class="comment">                this(initialCapacity, 0);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">         2. vector.add(i)</span></span><br><span class="line"><span class="comment">         2.1  //下面这个方法就添加数据到vector集合</span></span><br><span class="line"><span class="comment">            public synchronized boolean add(E e) &#123;</span></span><br><span class="line"><span class="comment">                modCount++;</span></span><br><span class="line"><span class="comment">                ensureCapacityHelper(elementCount + 1);</span></span><br><span class="line"><span class="comment">                elementData[elementCount++] = e;</span></span><br><span class="line"><span class="comment">                return true;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">          2.2  //确定是否需要扩容 条件 ： minCapacity - elementData.length&gt;0</span></span><br><span class="line"><span class="comment">            private void ensureCapacityHelper(int minCapacity) &#123;</span></span><br><span class="line"><span class="comment">                // overflow-conscious code</span></span><br><span class="line"><span class="comment">                if (minCapacity - elementData.length &gt; 0)</span></span><br><span class="line"><span class="comment">                    grow(minCapacity);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">          2.3 //如果 需要的数组大小 不够用，就扩容 , 扩容的算法</span></span><br><span class="line"><span class="comment">              //newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?</span></span><br><span class="line"><span class="comment">              //                             capacityIncrement : oldCapacity);</span></span><br><span class="line"><span class="comment">              //就是扩容两倍.</span></span><br><span class="line"><span class="comment">            private void grow(int minCapacity) &#123;</span></span><br><span class="line"><span class="comment">                // overflow-conscious code</span></span><br><span class="line"><span class="comment">                int oldCapacity = elementData.length;</span></span><br><span class="line"><span class="comment">                int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?</span></span><br><span class="line"><span class="comment">                                                 capacityIncrement : oldCapacity);</span></span><br><span class="line"><span class="comment">                if (newCapacity - minCapacity &lt; 0)</span></span><br><span class="line"><span class="comment">                    newCapacity = minCapacity;</span></span><br><span class="line"><span class="comment">                if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span></span><br><span class="line"><span class="comment">                    newCapacity = hugeCapacity(minCapacity);</span></span><br><span class="line"><span class="comment">                elementData = Arrays.copyOf(elementData, newCapacity);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="ArrayList和Vector："><a href="#ArrayList和Vector：" class="headerlink" title="ArrayList和Vector："></a>ArrayList和Vector：</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3833/%E6%88%AA%E5%B1%8F2022-05-26%2011.43.18.jpg" alt="截屏2022-05-26 11.43.18"></p></li></ul><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><ul><li><h4 id="注意事项和细节：-2"><a href="#注意事项和细节：-2" class="headerlink" title="注意事项和细节："></a>注意事项和细节：</h4><ol><li>LinkedList底层实现了双向链表和双端队列特点</li><li>可以添加任意元素包括null</li><li>线程不安全，没有实现同步</li></ol></li><li><h4 id="底层机制："><a href="#底层机制：" class="headerlink" title="底层机制："></a>底层机制：</h4><ol><li><p>Linkedlist底层维护了一个<strong>双向链表</strong></p></li><li><p>Linkedlist中维护了两个属性first和last分别指向首节点和尾节点</p></li><li><p>每个节点（Node对象），里面又维护了prev、next.item三个属性，其中通过<br>prev指向前一个，通过next指向后一个节点。最终实现双向链表</p></li><li><p>所以LinkedList的元素的添加和删除，不是通过数组完成的，相对来说效率较高</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3833/%E6%88%AA%E5%B1%8F2022-05-26%2019.18.01.jpg" alt="截屏2022-05-26 19.18.01"></p></li></ol></li><li><h4 id="ArrayList和LinkedList："><a href="#ArrayList和LinkedList：" class="headerlink" title="ArrayList和LinkedList："></a>ArrayList和LinkedList：</h4><ol><li><p>如果我们改查的操作多，选择ArrayList</p></li><li><p>如果我们增删的操作多，选择LinkedList</p></li><li><p>一般来说，在程序中，80%-90%都是查询，因此大部分情况下会选择ArrayList</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3833/%E6%88%AA%E5%B1%8F2022-05-26%2019.20.03.jpg" alt="截屏2022-05-26 19.20.03"></p></li></ol></li></ul><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ul><li><h4 id="基本介绍：-4"><a href="#基本介绍：-4" class="headerlink" title="基本介绍："></a>基本介绍：</h4><ul><li>无序（添加和取出的顺序不一致），没有索引</li><li>不允许重复元素，所以最多包含一个null</li><li>JDK API中Set接口的实现类有：<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3833/%E6%88%AA%E5%B1%8F2022-05-26%2019.21.30.jpg" alt="截屏2022-05-26 19.21.30"></li></ul></li><li><h4 id="常用方法：-1"><a href="#常用方法：-1" class="headerlink" title="常用方法："></a>常用方法：</h4><ul><li><p>add：添加单个元素</p></li><li><p>remove：删除指定元素</p></li><li><p>contains：查找元素是否存在</p></li><li><p>size：获取元素个数</p></li><li><p>isEmpty：判断是否为空</p></li><li><p>clear：清空</p></li><li><p>addAll：添加多个元素</p></li><li><p>containsAll：查找多个元素是否都存在</p></li><li><p>removeAll：删除多个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//老韩解读</span></span><br><span class="line">        <span class="comment">//1. 以Set 接口的实现类 HashSet 来讲解Set 接口的方法</span></span><br><span class="line">        <span class="comment">//2. set 接口的实现类的对象(Set接口对象), 不能存放重复的元素, 可以添加一个null</span></span><br><span class="line">        <span class="comment">//3. set 接口对象存放数据是无序(即添加的顺序和取出的顺序不一致)</span></span><br><span class="line">        <span class="comment">//4. 注意：取出的顺序的顺序虽然不是添加的顺序，但是他的固定.</span></span><br><span class="line">        <span class="type">Set</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">        set.add(<span class="string">&quot;john&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;lucy&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;john&quot;</span>);<span class="comment">//重复</span></span><br><span class="line">        set.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;hsp&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;mary&quot;</span>);</span><br><span class="line">        set.add(<span class="literal">null</span>);<span class="comment">//</span></span><br><span class="line">        set.add(<span class="literal">null</span>);<span class="comment">//再次添加null</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">10</span>;i ++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;set=&quot;</span> + set);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="comment">//方式1： 使用迭代器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;=====使用迭代器====&quot;</span>);</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span>  iterator.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;obj=&quot;</span> + obj);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        set.remove(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式2: 增强for</span></span><br><span class="line">        System.out.println(<span class="string">&quot;=====增强for====&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Object o : set) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;o=&quot;</span> + o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//set 接口对象，不能通过索引来获取</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><h4 id="遍历方式："><a href="#遍历方式：" class="headerlink" title="遍历方式："></a>遍历方式：</h4><ol><li>迭代器</li><li>增强for</li><li><strong>不能使用索引方式获取</strong>（普通遍历循环）</li></ol></li></ul><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><ul><li><h4 id="注意事项和细节：-3"><a href="#注意事项和细节：-3" class="headerlink" title="注意事项和细节："></a>注意事项和细节：</h4><ol><li>Hashset实现了Set接口</li><li>Hashset实际上是HashMap</li><li><strong>可以存放null值，但是只能有一个null</strong></li><li>Hashset不保证元素是有序的,取决于hash后，再确定索引的结果</li><li><strong>不能有重复元素&#x2F;对象</strong></li></ol></li><li><h4 id="底层机制和源码分析：-1"><a href="#底层机制和源码分析：-1" class="headerlink" title="底层机制和源码分析："></a>底层机制和源码分析：</h4><ol><li><p>HashSet 底层是 HashMap</p></li><li><p>添加一个元素时，先得到hash值会转成索引值</p></li><li><p>找到存储数据表table，看这个素引位置是否己经存放的有元素如果没有，直接加入</p></li><li><p>如果有调用equals 比较，如果相同，就放奔添加，如果不相同，则添加到最后</p></li><li><p>在Java8中，如果一条链表的元素个数超过 TREEIFY THRESHOLD（默认是8），井且table的大小＞&#x3D;MIN TREEIFY CAPACITY（默认64)就会进行树化(红黑树）</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3833/%E6%88%AA%E5%B1%8F2022-05-27%2011.48.11.jpg" alt="截屏2022-05-27 11.48.11"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSetSource</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">HashSet</span> <span class="variable">hashSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">        hashSet.add(<span class="string">&quot;java&quot;</span>);<span class="comment">//到此位置，第1次add分析完毕.</span></span><br><span class="line">        hashSet.add(<span class="string">&quot;php&quot;</span>);<span class="comment">//到此位置，第2次add分析完毕</span></span><br><span class="line">        hashSet.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;set=&quot;</span> + hashSet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        HashSet 的源码解读</span></span><br><span class="line"><span class="comment">        1. 执行 HashSet()</span></span><br><span class="line"><span class="comment">            public HashSet() &#123;</span></span><br><span class="line"><span class="comment">                map = new HashMap&lt;&gt;();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        2. 执行 add()</span></span><br><span class="line"><span class="comment">           public boolean add(E e) &#123;//e = &quot;java&quot;</span></span><br><span class="line"><span class="comment">                return map.put(e, PRESENT)==null;//(static) PRESENT = new Object();</span></span><br><span class="line"><span class="comment">           &#125;</span></span><br><span class="line"><span class="comment">         3.执行 put() , 该方法会执行 hash(key) 得到key对应的hash值 算法h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</span></span><br><span class="line"><span class="comment">             public V put(K key, V value) &#123;//key = &quot;java&quot; value = PRESENT 共享</span></span><br><span class="line"><span class="comment">                return putVal(hash(key), key, value, false, true);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">         4.执行 putVal</span></span><br><span class="line"><span class="comment">         final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span></span><br><span class="line"><span class="comment">                   boolean evict) &#123;</span></span><br><span class="line"><span class="comment">                Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //定义了辅助变量</span></span><br><span class="line"><span class="comment">                //table 就是 HashMap 的一个数组，类型是 Node[]</span></span><br><span class="line"><span class="comment">                //if 语句表示如果当前table 是null, 或者 大小=0</span></span><br><span class="line"><span class="comment">                //就是第一次扩容，到16个空间.</span></span><br><span class="line"><span class="comment">                if ((tab = table) == null || (n = tab.length) == 0)</span></span><br><span class="line"><span class="comment">                    n = (tab = resize()).length;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                //(1)根据key，得到hash 去计算该key应该存放到table表的哪个索引位置</span></span><br><span class="line"><span class="comment">                //并把这个位置的对象，赋给 p</span></span><br><span class="line"><span class="comment">                //(2)判断p 是否为null</span></span><br><span class="line"><span class="comment">                //(2.1) 如果p 为null, 表示还没有存放元素, 就创建一个Node (key=&quot;java&quot;,value=PRESENT)</span></span><br><span class="line"><span class="comment">                //(2.2) 就放在该位置 tab[i] = newNode(hash, key, value, null)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                if ((p = tab[i = (n - 1) &amp; hash]) == null)</span></span><br><span class="line"><span class="comment">                    tab[i] = newNode(hash, key, value, null);</span></span><br><span class="line"><span class="comment">                else &#123;</span></span><br><span class="line"><span class="comment">                    //一个开发技巧提示： 在需要局部变量(辅助变量)时候，在创建</span></span><br><span class="line"><span class="comment">                    Node&lt;K,V&gt; e; K k; //</span></span><br><span class="line"><span class="comment">                    //如果当前索引位置对应的链表的第一个元素和准备添加的key的hash值一样</span></span><br><span class="line"><span class="comment">                    //并且满足 下面两个条件之一:</span></span><br><span class="line"><span class="comment">                    //(1) 准备加入的key 和 p 指向的Node 结点的 key 是同一个对象</span></span><br><span class="line"><span class="comment">                    //(2)  p 指向的Node 结点的 key 的equals() 和准备加入的key比较后相同</span></span><br><span class="line"><span class="comment">                    //就不能加入</span></span><br><span class="line"><span class="comment">                    if (p.hash == hash &amp;&amp;</span></span><br><span class="line"><span class="comment">                        ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span></span><br><span class="line"><span class="comment">                        e = p;</span></span><br><span class="line"><span class="comment">                    //再判断 p 是不是一颗红黑树,</span></span><br><span class="line"><span class="comment">                    //如果是一颗红黑树，就调用 putTreeVal , 来进行添加</span></span><br><span class="line"><span class="comment">                    else if (p instanceof TreeNode)</span></span><br><span class="line"><span class="comment">                        e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span></span><br><span class="line"><span class="comment">                    else &#123;//如果table对应索引位置，已经是一个链表, 就使用for循环比较</span></span><br><span class="line"><span class="comment">                    </span></span><br><span class="line"><span class="comment">                          //(1) 依次和该链表的每一个元素比较后，都不相同, 则加入到该链表的最后</span></span><br><span class="line"><span class="comment">                          //    注意在把元素添加到链表后，立即判断 该链表是否已经达到8个结点</span></span><br><span class="line"><span class="comment">                          //    , 就调用 treeifyBin() 对当前这个链表进行树化(转成红黑树)</span></span><br><span class="line"><span class="comment">                          //    注意，在转成红黑树时，要进行判断, 判断条件</span></span><br><span class="line"><span class="comment">                          //    if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY(64))</span></span><br><span class="line"><span class="comment">                          //            resize();</span></span><br><span class="line"><span class="comment">                          //    如果上面条件成立，先table扩容.</span></span><br><span class="line"><span class="comment">                          //    只有上面条件不成立时，才进行转成红黑树</span></span><br><span class="line"><span class="comment">                          //(2) 依次和该链表的每一个元素比较过程中，如果有相同情况,就直接break</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                        for (int binCount = 0; ; ++binCount) &#123;</span></span><br><span class="line"><span class="comment">                            if ((e = p.next) == null) &#123;</span></span><br><span class="line"><span class="comment">                                p.next = newNode(hash, key, value, null);</span></span><br><span class="line"><span class="comment">                                if (binCount &gt;= TREEIFY_THRESHOLD(8) - 1) // -1 for 1st</span></span><br><span class="line"><span class="comment">                                    treeifyBin(tab, hash);</span></span><br><span class="line"><span class="comment">                                break;</span></span><br><span class="line"><span class="comment">                            &#125;</span></span><br><span class="line"><span class="comment">                            if (e.hash == hash &amp;&amp;</span></span><br><span class="line"><span class="comment">                                ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span></span><br><span class="line"><span class="comment">                                break;</span></span><br><span class="line"><span class="comment">                            p = e;</span></span><br><span class="line"><span class="comment">                        &#125;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                    if (e != null) &#123; // existing mapping for key</span></span><br><span class="line"><span class="comment">                        V oldValue = e.value;</span></span><br><span class="line"><span class="comment">                        if (!onlyIfAbsent || oldValue == null)</span></span><br><span class="line"><span class="comment">                            e.value = value;</span></span><br><span class="line"><span class="comment">                        afterNodeAccess(e);</span></span><br><span class="line"><span class="comment">                        return oldValue;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                ++modCount;</span></span><br><span class="line"><span class="comment">                //size 就是我们每加入一个结点Node(k,v,h,next), size++</span></span><br><span class="line"><span class="comment">                if (++size &gt; threshold)</span></span><br><span class="line"><span class="comment">                    resize();//扩容</span></span><br><span class="line"><span class="comment">                afterNodeInsertion(evict);</span></span><br><span class="line"><span class="comment">                return null;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><h4 id="扩容和红黑树机制："><a href="#扩容和红黑树机制：" class="headerlink" title="扩容和红黑树机制："></a>扩容和红黑树机制：</h4><ol><li>HashSet底层是HashMap</li><li>第一次添加时，table 数组扩容到 16，临界值(threshold)是 16*加载因子(loadFactor)是0.75&#x3D; 12</li><li>每加入一个节点，size就会++，到达临界值就会扩容</li><li>如果table 数组使用到了临界值 12,就会扩容到16*2&#x3D;32,新的临界值就是32*0.75&#x3D;24，依次类推</li><li>在Java8中，如果一条链表的元素个数到达 TREEIFY_ THRESHOLD(默认是 8）井且table的大小＞&#x3D;MIN TREEIFY CAPACITY (默认64),就会进行树化(红黑树），否则仍然采用数组扩容机制</li></ol></li><li><h4 id="去重机制对比："><a href="#去重机制对比：" class="headerlink" title="去重机制对比："></a>去重机制对比：</h4><ul><li>HashSet去重机制: hashCode() + equals()，底层先通过存入对象，通过运算hash值得到对应的索引，如果table索引所在的位置没有数据就直接存放；如果有数据就进行<strong>equals</strong>（注意重写情况）比较[遍历比较]，如果比较后，不相同就加入，否则就不加入</li><li>TreeSet的去重机制：如果你传入了一个Comparator匿名对象，就使用实现的compare去重，如果方法返回0,就是相同的元素&#x2F;数据，就不添加，如果你没有传入一个Comparator匿名对象，则以你添加的对象实现的Compareable接口的compareTo去重</li></ul></li><li><h4 id="例："><a href="#例：" class="headerlink" title="例："></a>例：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Homework06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();<span class="comment">//ok</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>,<span class="string">&quot;AA&quot;</span>);<span class="comment">//ok</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1002</span>,<span class="string">&quot;BB&quot;</span>);<span class="comment">//ok</span></span><br><span class="line">        set.add(p1);<span class="comment">//ok</span></span><br><span class="line">        set.add(p2);<span class="comment">//ok</span></span><br><span class="line">        p1.name = <span class="string">&quot;CC&quot;</span>;</span><br><span class="line">        set.remove(p1);</span><br><span class="line">        System.out.println(set);<span class="comment">//2</span></span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>,<span class="string">&quot;CC&quot;</span>));</span><br><span class="line">        System.out.println(set);<span class="comment">//3</span></span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>,<span class="string">&quot;AA&quot;</span>));</span><br><span class="line">        System.out.println(set);<span class="comment">//4</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) o;</span><br><span class="line">        <span class="keyword">return</span> id == person.id &amp;&amp;</span><br><span class="line">                Objects.equals(name, person.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3833/%E6%88%AA%E5%B1%8F2022-05-30%2011.03.03.jpg" alt="截屏2022-05-30 11.03.03"></p></li></ul><h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><ul><li><h4 id="注意事项和细节：-4"><a href="#注意事项和细节：-4" class="headerlink" title="注意事项和细节："></a>注意事项和细节：</h4><ol><li><p>LinkedHashset 是Hashset 的子类</p></li><li><p>LinkedHashSet 底层是一个 LinkedHashMap，底层维护了一个 数组＋<strong>双向链表</strong></p></li><li><p>LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置，同时使用链表维护元素的次序(图)，这使得元素看起来是以插入顺序保存的</p></li><li><p>LinkedHashSet 不允许添重复元素</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3833/%E6%88%AA%E5%B1%8F2022-05-29%2016.49.06.jpg" alt="截屏2022-05-29 16.49.06"></p></li></ol></li><li><h4 id="底层机制和源代码分析："><a href="#底层机制和源代码分析：" class="headerlink" title="底层机制和源代码分析："></a>底层机制和源代码分析：</h4><ol><li>LinkedHashSet 加入顺序和取出元素&#x2F;数据的顺序一致</li><li>LinkedHashSet 底层维护的是一个LinkedHashMap(是HashMap的子类)</li><li>LinkedHashSet 底层结构 (数组table+双向链表)</li><li>添加第一次时，直接将 数组table 扩容到 16 ,存放的结点类型是 LinkedHashMap$Entry</li><li>数组是 HashMap$Node[] 存放的元素&#x2F;数据是 LinkedHashMap$Entry类型</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashSetSource</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//分析一下LinkedHashSet的底层机制</span></span><br><span class="line">        <span class="type">Set</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>();</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;AA&quot;</span>));</span><br><span class="line">        set.add(<span class="number">456</span>);</span><br><span class="line">        set.add(<span class="number">456</span>);</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">Customer</span>(<span class="string">&quot;刘&quot;</span>, <span class="number">1001</span>));</span><br><span class="line">        set.add(<span class="number">123</span>);</span><br><span class="line">        set.add(<span class="string">&quot;HSP&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;set=&quot;</span> + set);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1. LinkedHashSet 加入顺序和取出元素/数据的顺序一致</span></span><br><span class="line">        <span class="comment">//2. LinkedHashSet 底层维护的是一个LinkedHashMap(是HashMap的子类)</span></span><br><span class="line">        <span class="comment">//3. LinkedHashSet 底层结构 (数组table+双向链表)</span></span><br><span class="line">        <span class="comment">//4. 添加第一次时，直接将 数组table 扩容到 16 ,存放的结点类型是 LinkedHashMap$Entry</span></span><br><span class="line">        <span class="comment">//5. 数组是 HashMap$Node[] 存放的元素/数据是 LinkedHashMap$Entry类型</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                //继承关系是在内部类完成.</span></span><br><span class="line"><span class="comment">                static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;</span></span><br><span class="line"><span class="comment">                    Entry&lt;K,V&gt; before, after;</span></span><br><span class="line"><span class="comment">                    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span></span><br><span class="line"><span class="comment">                        super(hash, key, value, next);</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> no;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">(String name, <span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><ul><li><h4 id="底层机制：-1"><a href="#底层机制：-1" class="headerlink" title="底层机制："></a>底层机制：</h4><ol><li><p>TreeSet()构造器需传入Comparator接口的匿名内部类，因为底层 Comparable&lt;? super K&gt; k &#x3D; (Comparator&lt;? super K&gt;) key;</p><p>若没有传入，则需要把传入的类实现Comparable接口</p></li><li><p>若按照compare方法比较value相同则无法加入value</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSet_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 当我们使用无参构造器，创建TreeSet时，默认按字母排序</span></span><br><span class="line">        <span class="comment">//2. 老师希望添加的元素，按照字符串大小来排序</span></span><br><span class="line">        <span class="comment">//3. 使用TreeSet 提供的一个构造器，可以传入一个比较器(匿名内部类)</span></span><br><span class="line">        <span class="comment">//   并指定排序规则</span></span><br><span class="line">        <span class="comment">//4. 简单看看源码</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1. 构造器把传入的比较器对象，赋给了 TreeSet的底层的 TreeMap的属性this.comparator</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         public TreeMap(Comparator&lt;? super K&gt; comparator) &#123;</span></span><br><span class="line"><span class="comment">                this.comparator = comparator;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">         2. 在 调用 treeSet.add(&quot;tom&quot;), 在底层会执行到</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">             if (cpr != null) &#123;//cpr 就是我们的匿名内部类(对象)</span></span><br><span class="line"><span class="comment">                do &#123;</span></span><br><span class="line"><span class="comment">                    parent = t;</span></span><br><span class="line"><span class="comment">                    //动态绑定到我们的匿名内部类(对象)compare</span></span><br><span class="line"><span class="comment">                    cmp = cpr.compare(key, t.key);</span></span><br><span class="line"><span class="comment">                    if (cmp &lt; 0)</span></span><br><span class="line"><span class="comment">                        t = t.left;</span></span><br><span class="line"><span class="comment">                    else if (cmp &gt; 0)</span></span><br><span class="line"><span class="comment">                        t = t.right;</span></span><br><span class="line"><span class="comment">                    else //如果相等，即返回0,这个Key就没有加入</span></span><br><span class="line"><span class="comment">                        return t.setValue(value);</span></span><br><span class="line"><span class="comment">                &#125; while (t != null);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        TreeSet treeSet = new TreeSet();</span></span><br><span class="line">        <span class="type">TreeSet</span> <span class="variable">treeSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>(<span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">                <span class="comment">//下面 调用String的 compareTo方法进行字符串大小比较</span></span><br><span class="line">                <span class="comment">//如果老韩要求加入的元素，按照长度大小排序</span></span><br><span class="line">                <span class="comment">//return ((String) o2).compareTo((String) o1);</span></span><br><span class="line">                <span class="keyword">return</span> ((String) o1).length() - ((String) o2).length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//添加数据.</span></span><br><span class="line">        treeSet.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;tom&quot;</span>);<span class="comment">//3</span></span><br><span class="line">        treeSet.add(<span class="string">&quot;sp&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;abc&quot;</span>);<span class="comment">//3</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;treeSet=&quot;</span> + treeSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul><li><h4 id="注意事项和细节：-5"><a href="#注意事项和细节：-5" class="headerlink" title="注意事项和细节："></a>注意事项和细节：</h4><ol><li><p>Map与Collection井列存在，用于保存具有映射关系的数据</p></li><li><p><strong>Map 中的key 和 value 可以是任何引用类型的数据，会封装到HashMap$Node对象中</strong></p></li><li><p>Map 中的key 不允许重复，原因和HashSet 一样</p></li><li><p>Map 中的value 可以重复</p></li><li><p>Map 的key可以为null，value也可以为null，key为null只有能有一个，value为null可以为多个</p></li><li><p>常用String类作为Map的key</p></li><li><p>key 和 value 之间存在单向一对一关系，即通过指定的 key 总能找到对应的 value</p></li><li><p>Map存放数据的key-value示意图，一对 k-y是放在一个Node中的，有因为Node 实现了 Entry 接口</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3833/%E6%88%AA%E5%B1%8F2022-05-27%2023.07.17.jpg" alt="截屏2022-05-27 23.07.17"></p></li></ol></li><li><h4 id="常用方法：-2"><a href="#常用方法：-2" class="headerlink" title="常用方法："></a>常用方法：</h4><ul><li><p>put：添加</p></li><li><p>remove：根据键删除映射关系</p></li><li><p>get：根据键获取值</p></li><li><p>size：获取元素个数</p></li><li><p>isEmpty：判断个数是否为0</p></li><li><p>clear：清除</p></li><li><p>containskey：查找键是否存在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//演示map接口常用方法</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;邓超&quot;</span>, <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;&quot;</span>, <span class="number">100</span>));<span class="comment">//OK</span></span><br><span class="line">        map.put(<span class="string">&quot;邓超&quot;</span>, <span class="string">&quot;孙俪&quot;</span>);<span class="comment">//替换-&gt; 一会分析源码</span></span><br><span class="line">        map.put(<span class="string">&quot;王宝强&quot;</span>, <span class="string">&quot;马蓉&quot;</span>);<span class="comment">//OK</span></span><br><span class="line">        map.put(<span class="string">&quot;宋喆&quot;</span>, <span class="string">&quot;马蓉&quot;</span>);<span class="comment">//OK</span></span><br><span class="line">        map.put(<span class="string">&quot;刘令博&quot;</span>, <span class="literal">null</span>);<span class="comment">//OK</span></span><br><span class="line">        map.put(<span class="literal">null</span>, <span class="string">&quot;刘亦菲&quot;</span>);<span class="comment">//OK</span></span><br><span class="line">        map.put(<span class="string">&quot;鹿晗&quot;</span>, <span class="string">&quot;关晓彤&quot;</span>);<span class="comment">//OK</span></span><br><span class="line">        map.put(<span class="string">&quot;hsp&quot;</span>, <span class="string">&quot;hsp的老婆&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;map=&quot;</span> + map);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        remove:根据键删除映射关系</span></span><br><span class="line">        map.remove(<span class="literal">null</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;map=&quot;</span> + map);</span><br><span class="line"><span class="comment">//        get：根据键获取值</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">val</span> <span class="operator">=</span> map.get(<span class="string">&quot;鹿晗&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;val=&quot;</span> + val);</span><br><span class="line"><span class="comment">//        size:获取元素个数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;k-v=&quot;</span> + map.size());</span><br><span class="line"><span class="comment">//        isEmpty:判断个数是否为0</span></span><br><span class="line">        System.out.println(map.isEmpty());<span class="comment">//F</span></span><br><span class="line"><span class="comment">//        clear:清除k-v</span></span><br><span class="line">        <span class="comment">//map.clear();</span></span><br><span class="line">        System.out.println(<span class="string">&quot;map=&quot;</span> + map);</span><br><span class="line"><span class="comment">//        containsKey:查找键是否存在</span></span><br><span class="line">        System.out.println(<span class="string">&quot;结果=&quot;</span> + map.containsKey(<span class="string">&quot;hsp&quot;</span>));<span class="comment">//T</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Book</span><span class="params">(String name, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><h4 id="遍历方式：-1"><a href="#遍历方式：-1" class="headerlink" title="遍历方式："></a>遍历方式：</h4><ol><li><p>先取出 所有的Key , 通过Key 取出对应的Value</p></li><li><p>把所有的values取出</p></li><li><p>通过 EntrySet 来获取 k-v</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapFor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;邓超&quot;</span>, <span class="string">&quot;孙俪&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;王宝强&quot;</span>, <span class="string">&quot;马蓉&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;宋喆&quot;</span>, <span class="string">&quot;马蓉&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;刘令博&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        map.put(<span class="literal">null</span>, <span class="string">&quot;刘亦菲&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;鹿晗&quot;</span>, <span class="string">&quot;关晓彤&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一组: 先取出 所有的Key , 通过Key 取出对应的Value</span></span><br><span class="line">        <span class="type">Set</span> <span class="variable">keyset</span> <span class="operator">=</span> map.keySet();</span><br><span class="line">        <span class="comment">//(1) 增强for</span></span><br><span class="line">        System.out.println(<span class="string">&quot;---第一种方式-------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object key : keyset) &#123;</span><br><span class="line">            System.out.println(key + <span class="string">&quot;-&quot;</span> + map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//(2) 迭代器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----第二种方式--------&quot;</span>);</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> keyset.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span>  iterator.next();</span><br><span class="line">            System.out.println(key + <span class="string">&quot;-&quot;</span> + map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二组: 把所有的values取出</span></span><br><span class="line">        <span class="type">Collection</span> <span class="variable">values</span> <span class="operator">=</span> map.values();</span><br><span class="line">        <span class="comment">//这里可以使用所有的Collections使用的遍历方法</span></span><br><span class="line">        <span class="comment">//(1) 增强for</span></span><br><span class="line">        System.out.println(<span class="string">&quot;---取出所有的value 增强for----&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object value : values) &#123;</span><br><span class="line">            System.out.println(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//(2) 迭代器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;---取出所有的value 迭代器----&quot;</span>);</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator2</span> <span class="operator">=</span> values.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator2.hasNext()) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span>  iterator2.next();</span><br><span class="line">            System.out.println(value);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三组: 通过EntrySet 来获取 k-v</span></span><br><span class="line">        <span class="type">Set</span> <span class="variable">entrySet</span> <span class="operator">=</span> map.entrySet();<span class="comment">// EntrySet&lt;Map.Entry&lt;K,V&gt;&gt;</span></span><br><span class="line">        <span class="comment">//(1) 增强for</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----使用EntrySet 的 for增强(第3种)----&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object entry : entrySet) &#123;</span><br><span class="line">            <span class="comment">//将entry 转成 Map.Entry</span></span><br><span class="line">            Map.<span class="type">Entry</span> <span class="variable">m</span> <span class="operator">=</span> (Map.Entry) entry;</span><br><span class="line">            System.out.println(m.getKey() + <span class="string">&quot;-&quot;</span> + m.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//(2) 迭代器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----使用EntrySet 的 迭代器(第4种)----&quot;</span>);</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator3</span> <span class="operator">=</span> entrySet.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator3.hasNext()) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">entry</span> <span class="operator">=</span>  iterator3.next();</span><br><span class="line">            <span class="comment">//System.out.println(next.getClass());//HashMap$Node -实现-&gt; Map.Entry (getKey,getValue)</span></span><br><span class="line">            <span class="comment">//向下转型 Map.Entry</span></span><br><span class="line">            Map.<span class="type">Entry</span> <span class="variable">m</span> <span class="operator">=</span> (Map.Entry) entry;</span><br><span class="line">            System.out.println(m.getKey() + <span class="string">&quot;-&quot;</span> + m.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><ul><li><h4 id="注意事项和细节：-6"><a href="#注意事项和细节：-6" class="headerlink" title="注意事项和细节："></a>注意事项和细节：</h4><ol><li>HashMap是Map 接口使用频率最高的实现类</li><li>Hashap 是以 key-val 对的方式来存储数据(HashMap$Node类型）</li><li><strong>key 不能重复，但是值可以重复，允许使用null和null值</strong></li><li><strong>如果添加相同的key，则会覆盖原来的key-val ，等同于修改（key不会替换，val会替换）</strong></li><li>与HashSet一样，不保证映射的顺序，因为底层是以hash表的方式来存储的(jdk8的hashMap 底层 数组＋链表＋红黑树）</li><li>HashMap没有实现同步，因此是线程不安全的，方法没有做同步互斥的操作，没有synchronized</li></ol></li><li><h4 id="底层机制和源码剖析："><a href="#底层机制和源码剖析：" class="headerlink" title="底层机制和源码剖析："></a>底层机制和源码剖析：</h4><ol><li>扩容机制和Hashset相同</li><li>HashMap底层维护了Node类型的数组table，默认为null</li><li>当创建对象时，将加载因子(loadfactor)初始化为0.75</li><li>当添加key-val时，通过key的哈希值得到在table的索引。然后判断该索引处是否有元素，如果没有元素直接添加。如果该索引处有元素，继续判断该元素的key是否和准备加入的key相等，如果相等，则直接替换val：如果不相等需要判断是树结构还是链表结构，做出相应处理。如果添加时发现容量不够，则需要扩容</li><li>第1次添加，则需要扩容table容量为16，临界值(threshold)为12</li><li>以后再扩容，则需要扩容table容量为原来的2倍，临界值为原来的2倍,即24，依次类推</li><li>在Java8中，如果一条链表的元素个数超过 TREEIFY THRESHOLD（默认是8），并且<br>table的大小＞&#x3D;MIN TREEIFY CAPACITY（默认64),就会进行树化（红黑树）</li></ol><p><img src="C:\Users\99301\AppData\Roaming\Typora\typora-user-images\image-20221205234933740.png" alt="image-20221205234933740"></p></li></ul><p><strong>Map中的keySet方法-返回将key值以set集合的方式返回</strong></p><p>1.Set 是java中一个存储不重复元素，且无序的集合类。<br>Map.keyset()，表示将map对象的所有key值已set集合的形式返回，因为map也是无序的，且key值也是不可重复的，因此这里用set集合存储key并返回也符合规则。</p><p>2.将Map中所有的键存入到set集合中。因为set具备迭代器。所有可以迭代方式取出所有的键，再根据get方法。获取每一个键对应的值。 keySet():迭代后只能通过get()取key。</p><p><strong>Map中的values方法-获取Map集合中的所有键值对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例  本示例创建一个Map集合对象并添加一些内容，然后调用values方法获取包含所有键值的集合对象，并输出这些键值信息。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();      <span class="comment">//定义Map集合对象</span></span><br><span class="line">    map.put(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;新鲜的苹果&quot;</span>);     <span class="comment">//向集合中添加对象</span></span><br><span class="line">    map.put(<span class="string">&quot;computer&quot;</span>, <span class="string">&quot;配置优良的计算机&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;book&quot;</span>, <span class="string">&quot;堆积成山的图书&quot;</span>);</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">values</span> <span class="operator">=</span> map.values();    <span class="comment">//获取Map集合的value集合</span></span><br><span class="line">    <span class="keyword">for</span> (Object object : values) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;键值：&quot;</span> + object.toString()); <span class="comment">//输出键值对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Map中entrySet()方法-获取到Map集合中所有的键值对对象的集合(Set集合)</strong></p><p>就是返回一个集合，集合里存放的是对象，创建对象的类有两个属性，分别是 键和值 也即<strong>键值对</strong>。<br>其中Entry是属于Map的静态内部类，在创建Map对象的时候就会同时创建一个Entry对象，用来记录键与值的映射关系。</p><p><img src="https://img-blog.csdnimg.cn/20200324133421256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY4OTE2MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapBlogTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建HashMap对象</span></span><br><span class="line">        HashMap&lt;String, String&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;键1&quot;</span>, <span class="string">&quot;值1&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;键2&quot;</span>, <span class="string">&quot;值2&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;键3&quot;</span>, <span class="string">&quot;值3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取对象的集合</span></span><br><span class="line">        Set&lt;Map.Entry&lt;String, String&gt;&gt; entries=map.entrySet();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用增强for遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; s : entries) &#123;</span><br><span class="line">            <span class="comment">//①可以直接输出 s 得到键值对</span></span><br><span class="line">            System.out.println(s);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//②也可以使用Entry类的方法 单独取出 键和值</span></span><br><span class="line">            String key=s.getKey();        <span class="comment">//获取键</span></span><br><span class="line">            String value=s.getValue();    <span class="comment">//获取值</span></span><br><span class="line">            System.out.println(key + <span class="string">&quot;=&quot;</span> + value);    <span class="comment">//输出键值</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用while用集合中的迭代器遍历</span></span><br><span class="line">        Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it=entries.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;String, String&gt; next=it.next();</span><br><span class="line">            System.out.println(next);</span><br><span class="line"></span><br><span class="line">            String key=next.getKey();        <span class="comment">//获取键</span></span><br><span class="line">            String value=next.getValue();    <span class="comment">//获取值</span></span><br><span class="line">            System.out.println(key + <span class="string">&quot;=&quot;</span> + value);    <span class="comment">//输出键值</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapSource1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;java&quot;</span>, <span class="number">10</span>);<span class="comment">//ok</span></span><br><span class="line">        map.put(<span class="string">&quot;php&quot;</span>, <span class="number">10</span>);<span class="comment">//ok</span></span><br><span class="line">        map.put(<span class="string">&quot;java&quot;</span>, <span class="number">20</span>);<span class="comment">//替换value</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;map=&quot;</span> + map);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*老韩解读HashMap的源码+图解</span></span><br><span class="line"><span class="comment">        1. 执行构造器 new HashMap()</span></span><br><span class="line"><span class="comment">           初始化加载因子 loadfactor = 0.75</span></span><br><span class="line"><span class="comment">           HashMap$Node[] table = null</span></span><br><span class="line"><span class="comment">        2. 执行put 调用 hash方法，计算 key的 hash值 (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</span></span><br><span class="line"><span class="comment">            public V put(K key, V value) &#123;//K = &quot;java&quot; value = 10</span></span><br><span class="line"><span class="comment">                return putVal(hash(key), key, value, false, true);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        3. 执行 putVal</span></span><br><span class="line"><span class="comment">         final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span></span><br><span class="line"><span class="comment">                   boolean evict) &#123;</span></span><br><span class="line"><span class="comment">                Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;//辅助变量</span></span><br><span class="line"><span class="comment">                //如果底层的table 数组为null, 或者 length =0 , 就扩容到16</span></span><br><span class="line"><span class="comment">                if ((tab = table) == null || (n = tab.length) == 0)</span></span><br><span class="line"><span class="comment">                    n = (tab = resize()).length;</span></span><br><span class="line"><span class="comment">                //取出hash值对应的table的索引位置的Node, 如果为null, 就直接把加入的k-v</span></span><br><span class="line"><span class="comment">                //, 创建成一个 Node ,加入该位置即可</span></span><br><span class="line"><span class="comment">                if ((p = tab[i = (n - 1) &amp; hash]) == null)</span></span><br><span class="line"><span class="comment">                    tab[i] = newNode(hash, key, value, null);</span></span><br><span class="line"><span class="comment">                else &#123;</span></span><br><span class="line"><span class="comment">                    Node&lt;K,V&gt; e; K k;//辅助变量</span></span><br><span class="line"><span class="comment">                // 如果table的索引位置的key的hash相同和新的key的hash值相同，</span></span><br><span class="line"><span class="comment">                 // 并 满足(table现有的结点的key和准备添加的key是同一个对象  || equals返回真)</span></span><br><span class="line"><span class="comment">                 // 就认为不能加入新的k-v</span></span><br><span class="line"><span class="comment">                    if (p.hash == hash &amp;&amp;</span></span><br><span class="line"><span class="comment">                        ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span></span><br><span class="line"><span class="comment">                        e = p;</span></span><br><span class="line"><span class="comment">                    else if (p instanceof TreeNode)//如果当前的table的已有的Node 是红黑树，就按照红黑树的方式处理</span></span><br><span class="line"><span class="comment">                        e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span></span><br><span class="line"><span class="comment">                    else &#123;</span></span><br><span class="line"><span class="comment">                        //如果找到的结点，后面是链表，就循环比较</span></span><br><span class="line"><span class="comment">                        for (int binCount = 0; ; ++binCount) &#123;//死循环</span></span><br><span class="line"><span class="comment">                            if ((e = p.next) == null) &#123;//如果整个链表，没有和他相同,就加到该链表的最后</span></span><br><span class="line"><span class="comment">                                p.next = newNode(hash, key, value, null);</span></span><br><span class="line"><span class="comment">                                //加入后，判断当前链表的个数，是否已经到8个，到8个，后</span></span><br><span class="line"><span class="comment">                                //就调用 treeifyBin 方法进行红黑树的转换</span></span><br><span class="line"><span class="comment">                                if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span></span><br><span class="line"><span class="comment">                                    treeifyBin(tab, hash);</span></span><br><span class="line"><span class="comment">                                break;</span></span><br><span class="line"><span class="comment">                            &#125;</span></span><br><span class="line"><span class="comment">                            if (e.hash == hash &amp;&amp; //如果在循环比较过程中，发现有相同,就break,就只是替换value</span></span><br><span class="line"><span class="comment">                                ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span></span><br><span class="line"><span class="comment">                                break;</span></span><br><span class="line"><span class="comment">                            p = e;</span></span><br><span class="line"><span class="comment">                        &#125;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                    if (e != null) &#123; // existing mapping for key</span></span><br><span class="line"><span class="comment">                        V oldValue = e.value;</span></span><br><span class="line"><span class="comment">                        if (!onlyIfAbsent || oldValue == null)</span></span><br><span class="line"><span class="comment">                            e.value = value; //替换，key对应value</span></span><br><span class="line"><span class="comment">                        afterNodeAccess(e);</span></span><br><span class="line"><span class="comment">                        return oldValue;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                ++modCount;//每增加一个Node ,就size++</span></span><br><span class="line"><span class="comment">                if (++size &gt; threshold[12-24-48])//如size &gt; 临界值，就扩容</span></span><br><span class="line"><span class="comment">                    resize();</span></span><br><span class="line"><span class="comment">                afterNodeInsertion(evict);</span></span><br><span class="line"><span class="comment">                return null;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">              5. 关于树化(转成红黑树)</span></span><br><span class="line"><span class="comment">              //如果table 为null ,或者大小还没有到 64，暂时不树化，而是进行扩容.</span></span><br><span class="line"><span class="comment">              //否则才会真正的树化 -&gt; 剪枝</span></span><br><span class="line"><span class="comment">              final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123;</span></span><br><span class="line"><span class="comment">                int n, index; Node&lt;K,V&gt; e;</span></span><br><span class="line"><span class="comment">                if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span></span><br><span class="line"><span class="comment">                    resize();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h4><ul><li><h4 id="注意事项和细节：-7"><a href="#注意事项和细节：-7" class="headerlink" title="注意事项和细节："></a>注意事项和细节：</h4><ol><li>存放的元素是键值对：即K-V</li><li><strong>hashtable的键和值都不能为null， 否则会抛出NulPointerException</strong></li><li>hashTable 使用方法基本上和HashMap一样</li><li>hashTable 是线程安全的(synchronized)，hashMap 是线程不安全的</li></ol></li><li><h4 id="底层机制：-2"><a href="#底层机制：-2" class="headerlink" title="底层机制："></a>底层机制：</h4><ol><li>底层有数组 Hashtable$Entry[] 初始化大小为 11</li><li>临界值 threshold 8 &#x3D; 11 * 0.75</li><li>扩容: 按照自己的扩容机制来进行即可</li><li>执行方法 addEntry(hash, key, value, index); 添加K-V 封装到Entry</li><li>当 if (count &gt;&#x3D; threshold) 满足时，就进行扩容</li><li>按照 int newCapacity &#x3D; (oldCapacity &lt;&lt; 1) + 1;的大小扩容</li></ol></li><li><h4 id="Hashtable和HashMapd"><a href="#Hashtable和HashMapd" class="headerlink" title="Hashtable和HashMapd:"></a>Hashtable和HashMapd:</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3833/%E6%88%AA%E5%B1%8F2022-05-29%2016.14.26.jpg" alt="截屏2022-05-29 16.14.26"></p></li></ul><h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><ul><li><h4 id="底层机制和源码剖析：-1"><a href="#底层机制和源码剖析：-1" class="headerlink" title="底层机制和源码剖析："></a>底层机制和源码剖析：</h4><ol><li><p>若按照compare方法比较key相同则无法加入value值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeMap_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用默认的构造器，创建TreeMap, 是字母排序</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            要求：按照传入的 k(String) 的大小进行排序</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="comment">//        TreeMap treeMap = new TreeMap();</span></span><br><span class="line">        <span class="type">TreeMap</span> <span class="variable">treeMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeMap</span>(<span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">                <span class="comment">//按照传入的 k(String) 的大小进行排序</span></span><br><span class="line">                <span class="comment">//按照K(String) 的长度大小排序</span></span><br><span class="line">                <span class="comment">//return ((String) o2).compareTo((String) o1);</span></span><br><span class="line">                <span class="keyword">return</span> ((String) o2).length() - ((String) o1).length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        treeMap.put(<span class="string">&quot;jack&quot;</span>, <span class="string">&quot;杰克&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="string">&quot;tom&quot;</span>, <span class="string">&quot;汤姆&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="string">&quot;kristina&quot;</span>, <span class="string">&quot;克瑞斯提诺&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="string">&quot;smith&quot;</span>, <span class="string">&quot;斯密斯&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="string">&quot;hsp&quot;</span>, <span class="string">&quot;韩顺平&quot;</span>);<span class="comment">//加入不了</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;treemap=&quot;</span> + treeMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            解读源码：</span></span><br><span class="line"><span class="comment">            1. 构造器. 把传入的实现了 Comparator接口的匿名内部类(对象)，传给给TreeMap的comparator</span></span><br><span class="line"><span class="comment">             public TreeMap(Comparator&lt;? super K&gt; comparator) &#123;</span></span><br><span class="line"><span class="comment">                this.comparator = comparator;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            2. 调用put方法</span></span><br><span class="line"><span class="comment">            2.1 第一次添加, 把k-v 封装到 Entry对象，放入root</span></span><br><span class="line"><span class="comment">            Entry&lt;K,V&gt; t = root;</span></span><br><span class="line"><span class="comment">            if (t == null) &#123;</span></span><br><span class="line"><span class="comment">                compare(key, key); // type (and possibly null) check</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                root = new Entry&lt;&gt;(key, value, null);</span></span><br><span class="line"><span class="comment">                size = 1;</span></span><br><span class="line"><span class="comment">                modCount++;</span></span><br><span class="line"><span class="comment">                return null;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            2.2 以后添加</span></span><br><span class="line"><span class="comment">            Comparator&lt;? super K&gt; cpr = comparator;</span></span><br><span class="line"><span class="comment">            if (cpr != null) &#123;</span></span><br><span class="line"><span class="comment">                do &#123; //遍历所有的key , 给当前key找到适当位置</span></span><br><span class="line"><span class="comment">                    parent = t;</span></span><br><span class="line"><span class="comment">                    cmp = cpr.compare(key, t.key);//动态绑定到我们的匿名内部类的compare</span></span><br><span class="line"><span class="comment">                    if (cmp &lt; 0)</span></span><br><span class="line"><span class="comment">                        t = t.left;</span></span><br><span class="line"><span class="comment">                    else if (cmp &gt; 0)</span></span><br><span class="line"><span class="comment">                        t = t.right;</span></span><br><span class="line"><span class="comment">                    else  //如果遍历过程中，发现准备添加Key 和当前已有的Key 相等，就不添加</span></span><br><span class="line"><span class="comment">                        return t.setValue(value);</span></span><br><span class="line"><span class="comment">                &#125; while (t != null);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h4 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h4><ul><li><h4 id="注意事项和细节：-8"><a href="#注意事项和细节：-8" class="headerlink" title="注意事项和细节："></a>注意事项和细节：</h4><ol><li><p>Properties类继承Hashtable类，实现了Map接口，也是使用一种简直对的形式保存数据</p></li><li><p>使用特点和Hashtable类似</p></li><li><p>Properties 还可以用于 从xxx.properties 文件中，加载数据到Properties类对象井进行读取和修改</p></li><li><p>xxx.properties 文件通常作为配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Properties_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//1. Properties 继承  Hashtable</span></span><br><span class="line">        <span class="comment">//2. 可以通过 k-v 存放数据，当然key 和 value 不能为 null</span></span><br><span class="line">        <span class="comment">//增加</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">//properties.put(null, &quot;abc&quot;);//抛出 空指针异常</span></span><br><span class="line">        <span class="comment">//properties.put(&quot;abc&quot;, null); //抛出 空指针异常</span></span><br><span class="line">        properties.put(<span class="string">&quot;john&quot;</span>, <span class="number">100</span>);<span class="comment">//k-v</span></span><br><span class="line">        properties.put(<span class="string">&quot;lucy&quot;</span>, <span class="number">100</span>);</span><br><span class="line">        properties.put(<span class="string">&quot;lic&quot;</span>, <span class="number">100</span>);</span><br><span class="line">        properties.put(<span class="string">&quot;lic&quot;</span>, <span class="number">88</span>);<span class="comment">//如果有相同的key ， value被替换</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;properties=&quot;</span> + properties);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过k 获取对应值</span></span><br><span class="line">        System.out.println(properties.get(<span class="string">&quot;lic&quot;</span>));<span class="comment">//88</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除</span></span><br><span class="line">        properties.remove(<span class="string">&quot;lic&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;properties=&quot;</span> + properties);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改</span></span><br><span class="line">        properties.put(<span class="string">&quot;john&quot;</span>, <span class="string">&quot;约翰&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;properties=&quot;</span> + properties);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h4 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h4><ul><li><h4 id="基本介绍：-5"><a href="#基本介绍：-5" class="headerlink" title="基本介绍："></a>基本介绍：</h4><ul><li>Collections 是一个操作 Set.List 和 Map 等集合的工具类</li><li>Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作</li></ul></li><li><h4 id="常用方法：-3"><a href="#常用方法：-3" class="headerlink" title="常用方法："></a>常用方法：</h4><ul><li><p>排序操作：</p><ul><li>reverse (List)：反转List中元素顺序</li><li>shuffle(List)：对 List 集合元素进行随机排序</li><li>sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序</li><li>sort(List, Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</li><li>swap (List, int,int)：将指定 list 集合中的 i处元素和j处元素进行交换</li></ul></li><li><p>查找替换：</p><ul><li><p>Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素</p></li><li><p>Object max(Collection, Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素</p></li><li><p>Object min(Collection)</p></li><li><p>Object min(Collection, Comparator)</p></li><li><p>int frequency(Collection, Object)：返回指定集合中指定元素的出现次数</p></li><li><p>void copy(List dest, List src)：将src中的内容复制到dest中</p></li><li><p>boolean replaceAll(List list, Object oldVal, Object newVal)：使用新值替换 List 对象的所有旧值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Collections_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建ArrayList 集合，用于测试.</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list.add(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;smith&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;king&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;milan&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        reverse(List)：反转 List 中元素的顺序</span></span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"><span class="comment">//        shuffle(List)：对 List 集合元素进行随机排序</span></span><br><span class="line"><span class="comment">//        for (int i = 0; i &lt; 5; i++) &#123;</span></span><br><span class="line"><span class="comment">//            Collections.shuffle(list);</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;list=&quot; + list);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序</span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(<span class="string">&quot;自然排序后&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"><span class="comment">//        sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</span></span><br><span class="line">        <span class="comment">//我们希望按照 字符串的长度大小排序</span></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">                <span class="comment">//可以加入校验代码.</span></span><br><span class="line">                <span class="keyword">return</span> ((String) o2).length() - ((String) o1).length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;字符串长度大小排序=&quot;</span> + list);</span><br><span class="line"><span class="comment">//        swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//比如</span></span><br><span class="line">        Collections.swap(list, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;交换后的情况&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;自然顺序最大元素=&quot;</span> + Collections.max(list));</span><br><span class="line">        <span class="comment">//Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素</span></span><br><span class="line">        <span class="comment">//比如，我们要返回长度最大的元素</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">maxObject</span> <span class="operator">=</span> Collections.max(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> ((String)o1).length() - ((String)o2).length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;长度最大的元素=&quot;</span> + maxObject);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Object min(Collection)</span></span><br><span class="line">        <span class="comment">//Object min(Collection，Comparator)</span></span><br><span class="line">        <span class="comment">//上面的两个方法，参考max即可</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//int frequency(Collection，Object)：返回指定集合中指定元素的出现次数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;tom出现的次数=&quot;</span> + Collections.frequency(list, <span class="string">&quot;tom&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//void copy(List dest,List src)：将src中的内容复制到dest中</span></span><br><span class="line"></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">dest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="comment">//为了完成一个完整拷贝，我们需要先给dest 赋值，大小和list.size()一样</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            dest.add(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拷贝</span></span><br><span class="line">        Collections.copy(dest, list);</span><br><span class="line">        System.out.println(<span class="string">&quot;dest=&quot;</span> + dest);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所有旧值</span></span><br><span class="line">        <span class="comment">//如果list中，有tom 就替换成 汤姆</span></span><br><span class="line">        Collections.replaceAll(list, <span class="string">&quot;tom&quot;</span>, <span class="string">&quot;汤姆&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list替换后=&quot;</span> + list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>选择集合：</p><ul><li><p>先判断存储的类型（一组对象[单列]或一组键值对[双列]）</p></li><li><p>一组对象[单列]： Collection接口</p><ul><li><p>允许重复：List</p><p>增删多：LinkedList  [底层维护双向链表]</p><p>改查多：ArrayList  [底层維护 Object类型的可变数组]</p></li><li><p>不允许重复：Set</p><p>无序：HashSet  [底层是HashMap，维护了一个哈希表，即(数组＋链表＋红黑树)]</p><p>排序：Treeset  []</p><p>插入和取出顺序一致：LinkedHashSet  [底层维护数组＋双向链表]</p></li></ul></li><li><p>一组键[值对双列]：Map</p><ul><li>键无序：HashMap  [底层是：哈希表  jdk7：数组＋链表，jdk8:数组＋链表＋红黑树]</li><li>键排序：TreeMap  []</li><li>键插入和取出顺序一致：LinkedHashMap</li><li>读取文件 Propertie</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode</title>
      <link href="/2022/12/06/LeetCode/"/>
      <url>/2022/12/06/LeetCode/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383.赎金信"></a><strong>383.赎金信</strong></h2><p>给你两个字符串：<code>ransomNote</code> 和 <code>magazine</code> ，判断 <code>ransomNote</code> 能不能由 <code>magazine</code> 里面的字符构成。<br>如果可以，返回 <code>true</code> ；否则返回 <code>false</code> 。<br><code>magazine</code> 中的每个字符只能在 <code>ransomNote</code> 中使用一次。</p><p><strong>解题思路：</strong>首先，如果 ransomNote 的长度如果大于 magazine 的长度，必然是不能构成的</p><p>其次，我们可以把 magazine 中每个字母对应在数组 cnt 的索引处，统计每个字母出现的次数（即++），然后从 ransomNote 中依次遍历取到的字母，也对应在 cnt 的索引处，统计每个字母出现的次数（即–），只要当 cnt 此次对应的数量小于0，则认为false，否则为true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(ransomNote.length() &gt; magazine.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="comment">//统计二十六个元素中对应下角标中元素出现的次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : magazine.toCharArray())&#123;</span><br><span class="line">            cnt[c-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果减去之后小于0则认为不能构成</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : ransomNote.toCharArray())&#123;</span><br><span class="line">            cnt[c-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="keyword">if</span>(cnt[c-<span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>牛客刷题笔记</title>
      <link href="/2022/12/04/%E7%89%9B%E5%AE%A2%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/12/04/%E7%89%9B%E5%AE%A2%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-类的加载"><a href="#1-类的加载" class="headerlink" title="1.类的加载"></a>1.类的加载</h3><p>类的加载括：加载，验证，准备，解析，初始化。</p><p>生成java.lang.Class对象：生成java.lang.Class对象是在加载时进行的。生成Class对象作为方法区这个类的各种数据的访问入口。<br>int类型对象成员变量赋予默认值：既然是对象成员，那么肯定在实例化对象后才有。在类加载的时候会赋予初值的是类变量，而非对象成员。<br>类方法解析：类方法解析发生在解析过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CharToString</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="type">char</span> <span class="variable">myChar</span> <span class="operator">=</span> <span class="string">&#x27;g&#x27;</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">myStr</span> <span class="operator">=</span> Character.toString(myChar);</span><br><span class="line">  System.out.println(<span class="string">&quot;String is: &quot;</span>+myStr);</span><br><span class="line">  myStr = String.valueOf(myChar);</span><br><span class="line">  System.out.println(<span class="string">&quot;String is: &quot;</span>+myStr);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此段代码输出的值为：</span></span><br><span class="line">String is: g</span><br><span class="line">String is: g</span><br><span class="line"><span class="comment">// 返回的都是字符串,只有char变成 int 的时候才会变为对应的assic码</span></span><br></pre></td></tr></table></figure><h3 id="2-关于抽象类和接口的叙述"><a href="#2-关于抽象类和接口的叙述" class="headerlink" title="2.关于抽象类和接口的叙述"></a>2.关于抽象类和接口的叙述</h3><p>抽象类</p><p>特点:<br>1.抽象类中可以构造方法</p><p>2.抽象类中可以存在普通属性，方法，静态属性和方法。</p><p>3.抽象类中可以存在抽象方法。</p><p>4.<strong>如果一个类中有一个抽象方法，那么当前类一定是抽象类；抽象类中不一定有抽象方法。</strong></p><p>5.抽象类中的抽象方法，需要有子类实现，<strong>如果子类不实现，则子类也需要定义为抽象的。</strong></p><p>6,<strong>抽象类不能被实例化，抽象类和抽象方法必须被abstract修饰</strong></p><p>关键字使用注意：<br>抽象类中的抽象方法（其前有abstract修饰）不能用private、static、synchronized、native访问修饰符修饰。</p><p>接口</p><p>1.在接口中只有方法的声明，没有方法体。</p><p>2.<strong>在接口中只有常量，因为定义的变量，在编译的时候都会默认加上public static final</strong></p><p>3.<strong>在接口中的方法，永远都被public来修饰</strong>。</p><p>4.<strong>接口中没有构造方法，也不能实例化接口的对象</strong>。（所以接口不能继承类）</p><p>5.接口可以实现多继承</p><p>6.<strong>接口中定义的方法都需要有实现类来实现，如果实现类不能实现接口中的所有方法则实现类定义为抽象类。</strong></p><p>7，接口可以继承接口，用extends</p><h3 id="3-内部类"><a href="#3-内部类" class="headerlink" title="3.内部类"></a>3.内部类</h3><p>在Java中，可以将一个类定义在另一个类里面或者一个方法里边，这样的类称为内部类，广泛意义上的内部类一般包括四种：成员内部类，局部内部类，匿名内部类，静态内部类 。</p><p>1.成员内部类</p><p>（1）该类像是外部类的一个成员，可以无条件的访问外部类的所有成员属性和成员方法（包括private成员和静态成员）；</p><p>（2）成员内部类拥有与外部类同名的成员变量时，会发生隐藏现象，即默认情况下访问的是成员内部类中的成员。如果要访问外部类中的成员，需要以下形式访问：【外部类.this.成员变量  或  外部类.this.成员方法】；</p><p>（3）在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问；</p><p>（4）成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象；</p><p>（5）内部类可以拥有private访问权限、protected访问权限、public访问权限及包访问权限。如果成员内部类用private修饰，则只能在外部类的内部访问；如果用public修饰，则任何地方都能访问；如果用protected修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。外部类只能被public和包访问两种权限修饰。</p><p>2.局部内部类</p><p>（1）局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内；</p><p>（2）局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。</p><p>3.匿名内部类</p><p>（1）一般使用匿名内部类的方法来编写事件监听代码；</p><p>（2）匿名内部类是不能有访问修饰符和static修饰符的；</p><p>（3）匿名内部类是唯一一种没有构造器的类；</p><p>（4）匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。</p><p>4.内部静态类</p><p>（1）静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似；</p><p>（2）不能使用外部类的非static成员变量或者方法。</p><p>下列代码运行结果是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Value</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> i=<span class="number">15</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String argv[])</span>&#123;</span><br><span class="line">        Test t=<span class="keyword">new</span> <span class="title class_">Test</span>( );</span><br><span class="line">        t.first( );</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">first</span><span class="params">( )</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">5</span>;</span><br><span class="line">    Value v=<span class="keyword">new</span> <span class="title class_">Value</span>( );</span><br><span class="line">    v.i=<span class="number">25</span>;</span><br><span class="line">    second(v,i);</span><br><span class="line">    System.out.println(v.i);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">second</span><span class="params">(Value v,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    v.i = <span class="number">20</span>;</span><br><span class="line">    <span class="type">Value</span> <span class="variable">val</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Value</span>( );</span><br><span class="line">    v = val;</span><br><span class="line">    System.out.println(v.i+<span class="string">&quot; &quot;</span>+i);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内存图如下：</p><p><img src="https://uploadfiles.nowcoder.com/images/20160817/6316247_1471446548929_2F9F7E31EC51C5C37F5962B0F07D6A39" alt="img"></p><h3 id="4-final、finally和finalize的区别"><a href="#4-final、finally和finalize的区别" class="headerlink" title="4.final、finally和finalize的区别"></a>4.final、finally和finalize的区别</h3><p><strong>A，D考的一个知识点，final修饰变量，变量的引用（也就是指向的地址）不可变，但是引用的内容可以变（地址中的内容可变）。</strong></p><p><strong>B，finally表示总是执行。但是其实finally也有不执行的时候，但是这个题不要扣字眼。</strong></p><p><strong>1. 在try中调用System.exit(0)，强制退出了程序，finally块不执行。</strong></p><p><strong>2. 在进入try块前，出现了异常，finally块不执行。</strong></p><p><strong>C，finalize方法，这个选项错就错在，这个方法一个对象只能执行一次，只能在第一次进入被回收的队列，而且对象所属于的类重写了finalize方法才会被执行。第二次进入回收队列的时候，不会再执行其finalize方法，而是直接被二次标记，在下一次GC的时候被GC。</strong></p><p><strong>放一张图吧</strong></p><p><img src="https://uploadfiles.nowcoder.com/images/20180716/3807435_1531748778229_B1F90475F3162B313B750B56294240E0" alt="img"></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
