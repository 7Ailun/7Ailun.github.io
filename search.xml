<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL</title>
      <link href="/2022/12/13/MySQL/"/>
      <url>/2022/12/13/MySQL/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://pic.imgdb.cn/item/63987af4b1fccdcd36a55c25.png"></p><h2 id="SQL语句分类"><a href="#SQL语句分类" class="headerlink" title="SQL语句分类"></a>SQL语句分类</h2><ul><li><p>DDL：数据定义语句[create 表，库…]</p></li><li><p>DML：数据库操作语句[增加 insert，修改 update，删除 delect]</p></li><li><p>DQL：数据查询语句[select]</p></li><li><p>DCL：数据控制语句[管理数据库：比如用户权限 grand revoke]</p></li></ul><h3 id="DDL：数据定义语句"><a href="#DDL：数据定义语句" class="headerlink" title="DDL：数据定义语句"></a>DDL：数据定义语句</h3><h4 id="DDL-数据库操作"><a href="#DDL-数据库操作" class="headerlink" title="DDL-数据库操作"></a>DDL-数据库操作</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#cmd登录</span><br><span class="line">mysql <span class="operator">-</span>u root <span class="operator">-</span>p</span><br><span class="line">#查询所有数据库</span><br><span class="line"><span class="keyword">SHOW</span> DATABASES</span><br><span class="line"></span><br><span class="line">#使用指令创建数据库</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE db01</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> db01 # 如果不存在则创建</span><br><span class="line"></span><br><span class="line">#删除数据库指令</span><br><span class="line"><span class="keyword">DROP</span> [IF <span class="keyword">EXISTS</span>] DATABASE db01</span><br><span class="line"></span><br><span class="line">#创建一个使用utf8mb4字符集的db02数据库</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE db02 CHARSET utf8mb4</span><br><span class="line"></span><br><span class="line">#创建一个使用utf8字符集，并带校对规则的db03数据库</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE db03 CHARSET utf8 <span class="keyword">COLLATE</span> utf8_bin</span><br><span class="line">#校对规则 utf8_bin 区分大小写 默认utf8_general_ci 不区分大小写</span><br><span class="line"></span><br><span class="line">#下面是一条查询<span class="keyword">sql</span>，<span class="keyword">select</span> 查询 <span class="operator">*</span> 表示所有字段 <span class="keyword">FROM</span> 从哪个表</span><br><span class="line">#<span class="keyword">WHERE</span> 从哪个字段 NAME <span class="operator">=</span> <span class="string">&#x27;tom&#x27;</span> 查询的名字是tom</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;tom&#x27;</span></span><br><span class="line"></span><br><span class="line">#进入到数据库中</span><br><span class="line">USE 数据库名字();</span><br><span class="line"> </span><br><span class="line">#查询当前数据库</span><br><span class="line"><span class="keyword">SELECT</span> DATABASE();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="DDL-表操作-查询"><a href="#DDL-表操作-查询" class="headerlink" title="DDL-表操作-查询"></a>DDL-表操作-查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#查询当前数据库所有表 前提是进入数据库中</span><br><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br><span class="line">#查询数据库结构</span><br><span class="line"><span class="keyword">DESC</span> 表名;</span><br><span class="line">#查询指定表的建表语句</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名</span><br></pre></td></tr></table></figure><h4 id="DDL-表操作-创建"><a href="#DDL-表操作-创建" class="headerlink" title="DDL-表操作-创建"></a>DDL-表操作-创建</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名（</span><br><span class="line">字段<span class="number">1</span> 字段<span class="number">1</span>类型[COMMENT 字段<span class="number">1</span>注释],</span><br><span class="line">字段<span class="number">2</span> 字段<span class="number">2</span>类型[COMMENT 字段<span class="number">2</span>注释],</span><br><span class="line">字段<span class="number">3</span> 字段<span class="number">3</span>类型[COMMENT 字段<span class="number">3</span>注释],</span><br><span class="line">字段<span class="number">3</span> 字段<span class="number">1</span>类型[COMMENT 字段<span class="number">3</span>注释],</span><br><span class="line">......</span><br><span class="line">字段n 字段n类型[COMMENT 字段n注释]</span><br><span class="line">)[COMMENT 表注释];</span><br><span class="line">#注意：[...]为可选参数，最后一个字段后面没有逗号</span><br><span class="line">#<span class="keyword">desc</span> 表明 (查看表)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="DDl-表操作-数据类型"><a href="#DDl-表操作-数据类型" class="headerlink" title="DDl-表操作-数据类型"></a>DDl-表操作-数据类型</h4><p>MySQL中的数据类型很多，主要分为三类：数值类型、字符串类型、日期时间类型。</p><table><thead><tr><th align="left">类型</th><th align="left">大小</th><th align="left">范围（有符号）</th><th align="left">范围（无符号）</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">TINYINT</td><td align="left">1 Bytes</td><td align="left">(-128，127)</td><td align="left">(0，255)</td><td align="left">小整数值</td></tr><tr><td align="left">SMALLINT</td><td align="left">2 Bytes</td><td align="left">(-32 768，32 767)</td><td align="left">(0，65 535)</td><td align="left">大整数值</td></tr><tr><td align="left">MEDIUMINT</td><td align="left">3 Bytes</td><td align="left">(-8 388 608，8 388 607)</td><td align="left">(0，16 777 215)</td><td align="left">大整数值</td></tr><tr><td align="left">INT或INTEGER</td><td align="left">4 Bytes</td><td align="left">(-2 147 483 648，2 147 483 647)</td><td align="left">(0，4 294 967 295)</td><td align="left">大整数值</td></tr><tr><td align="left">BIGINT</td><td align="left">8 Bytes</td><td align="left">(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</td><td align="left">(0，18 446 744 073 709 551 615)</td><td align="left">极大整数值</td></tr><tr><td align="left">FLOAT</td><td align="left">4 Bytes</td><td align="left">(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td><td align="left">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td><td align="left">单精度 浮点数值</td></tr><tr><td align="left">DOUBLE</td><td align="left">8 Bytes</td><td align="left">(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td align="left">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td align="left">双精度 浮点数值</td></tr><tr><td align="left">DECIMAL</td><td align="left">对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td><td align="left">依赖于M和D的值</td><td align="left">依赖于M和D的值</td><td align="left">小数值</td></tr></tbody></table><h4 id="DDl-表操作-字符类型"><a href="#DDl-表操作-字符类型" class="headerlink" title="DDl-表操作-字符类型"></a>DDl-表操作-字符类型</h4><table><thead><tr><th align="left">类型</th><th align="left">大小</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">CHAR</td><td align="left">0-255 bytes</td><td align="left">定长字符串</td></tr><tr><td align="left">VARCHAR</td><td align="left">0-65535 bytes</td><td align="left">变长字符串</td></tr><tr><td align="left">TINYBLOB</td><td align="left">0-255 bytes</td><td align="left">不超过 255 个字符的二进制字符串</td></tr><tr><td align="left">TINYTEXT</td><td align="left">0-255 bytes</td><td align="left">短文本字符串</td></tr><tr><td align="left">BLOB</td><td align="left">0-65 535 bytes</td><td align="left">二进制形式的长文本数据</td></tr><tr><td align="left">TEXT</td><td align="left">0-65 535 bytes</td><td align="left">长文本数据</td></tr><tr><td align="left">MEDIUMBLOB</td><td align="left">0-16 777 215 bytes</td><td align="left">二进制形式的中等长度文本数据</td></tr><tr><td align="left">MEDIUMTEXT</td><td align="left">0-16 777 215 bytes</td><td align="left">中等长度文本数据</td></tr><tr><td align="left">LONGBLOB</td><td align="left">0-4 294 967 295 bytes</td><td align="left">二进制形式的极大文本数据</td></tr><tr><td align="left">LONGTEXT</td><td align="left">0-4 294 967 295 bytes</td><td align="left">极大文本数据</td></tr></tbody></table><h4 id="DDl-表操作-日期和事件类型"><a href="#DDl-表操作-日期和事件类型" class="headerlink" title="DDl-表操作-日期和事件类型"></a>DDl-表操作-日期和事件类型</h4><table><thead><tr><th align="left">类型</th><th align="left">大小 ( bytes)</th><th align="left">范围</th><th align="left">格式</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">DATE</td><td align="left">3</td><td align="left">1000-01-01&#x2F;9999-12-31</td><td align="left">YYYY-MM-DD</td><td align="left">日期值</td></tr><tr><td align="left">TIME</td><td align="left">3</td><td align="left">‘-838:59:59’&#x2F;‘838:59:59’</td><td align="left">HH:MM:SS</td><td align="left">时间值或持续时间</td></tr><tr><td align="left">YEAR</td><td align="left">1</td><td align="left">1901&#x2F;2155</td><td align="left">YYYY</td><td align="left">年份值</td></tr><tr><td align="left">DATETIME</td><td align="left">8</td><td align="left">‘1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’</td><td align="left">YYYY-MM-DD hh:mm:ss</td><td align="left">混合日期和时间值</td></tr><tr><td align="left">TIMESTAMP</td><td align="left">4</td><td align="left">‘1970-01-01 00:00:01’ UTC 到 ‘2038-01-19 03:14:07’ UTC结束时间是第 <strong>2147483647</strong> 秒，北京时间 <strong>2038-1-19 11:14:07</strong>，格林尼治时间 2038年1月19日 凌晨 03:14:07</td><td align="left">YYYY-MM-DD hh:mm:ss</td><td align="left">混合日期和时间值，时间戳</td></tr></tbody></table><h4 id="DDL-表操作-修改"><a href="#DDL-表操作-修改" class="headerlink" title="DDL-表操作-修改"></a>DDL-表操作-修改</h4><p>添加字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> 字段名 类型(长度) [COMMENT 注释] [约束];</span><br></pre></td></tr></table></figure><p>案例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#为emp表增加一个新的字段&quot;昵称&quot;为nickname，类型为<span class="type">varchar</span>(<span class="number">20</span>);\</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp <span class="keyword">ADD</span> nikname <span class="type">varchar</span>(<span class="number">20</span>) COMMENT <span class="string">&#x27;昵称&#x27;</span>;</span><br></pre></td></tr></table></figure><p>修改数据类型</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 MODIFY 字段名 新数据类型(长度);</span><br></pre></td></tr></table></figure><p>修改字段名和字段类型</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];</span><br></pre></td></tr></table></figure><p>案例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#将emp表的nickname字段修改为username，类型为<span class="type">varchar</span>(<span class="number">30</span>)</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp CHANGE nickname username <span class="type">varchar</span>(<span class="number">30</span>) COMMENT <span class="string">&#x27;昵称&#x27;</span>;  </span><br></pre></td></tr></table></figure><p>删除字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> 字段名;</span><br></pre></td></tr></table></figure><p>案例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#将emp表的字段username删除</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp <span class="keyword">DROP</span> username;</span><br></pre></td></tr></table></figure><p>修改表名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 RENAME <span class="keyword">TO</span> 新表名</span><br></pre></td></tr></table></figure><p>案例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#将emp表的表名修改为employee</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp RENAME <span class="keyword">TO</span> employee</span><br></pre></td></tr></table></figure><p>删除表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> [IF <span class="keyword">EXISTS</span>] 表名;</span><br></pre></td></tr></table></figure><p>删除指定表，并重新创建该表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> 表名;</span><br></pre></td></tr></table></figure><p>注意：在删除表时，表中的全部数据也会被删除</p><p>小结<img src="C:/Users/99301/AppData/Roaming/Typora/typora-user-images/image-20221211123942324.png" alt="image-20221211123942324"></p><h3 id="DML：数据库操作语句"><a href="#DML：数据库操作语句" class="headerlink" title="DML：数据库操作语句"></a>DML：数据库操作语句</h3><h4 id="DML-添加数据"><a href="#DML-添加数据" class="headerlink" title="DML-添加数据"></a>DML-添加数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1.</span>给指定字段添加数据</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 (字段名<span class="number">1</span>,字段名<span class="number">2.</span>...) <span class="keyword">VALUE</span> (值<span class="number">1</span>,值<span class="number">2.</span>...);</span><br><span class="line"># <span class="number">2.</span>给全部字段添加数据</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 <span class="keyword">VALUE</span> (值<span class="number">1</span>,值<span class="number">2.</span>...);</span><br><span class="line"># <span class="number">3.</span>批量添加数据</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 (字段名<span class="number">1</span>,字段名<span class="number">2</span>,.....) <span class="keyword">VALUE</span> (值<span class="number">1</span>，值<span class="number">2</span>,....),(值<span class="number">1</span>，值<span class="number">2</span>,....),(值<span class="number">1</span>，值<span class="number">2</span>,....);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 <span class="keyword">VALUE</span> (值<span class="number">1</span>，值<span class="number">2</span>,....),(值<span class="number">1</span>，值<span class="number">2</span>,....)；</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>插入数据时，指定的字段顺序需要与值的顺序时一一对应的。</li><li>字符串的日期数据应该包含在引号中。</li><li>插入的数据大小，应该在字段的规定范围内。</li></ul><h4 id="DML-修改数据"><a href="#DML-修改数据" class="headerlink" title="DML-修改数据"></a>DML-修改数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#不写while条件会修改整个表</span><br><span class="line"><span class="keyword">UPDATE</span> 表名 <span class="keyword">SET</span> 字段名 <span class="operator">=</span> 值<span class="number">1</span>，字段名 <span class="operator">=</span> 值<span class="number">2.</span>..... [<span class="keyword">WHERE</span> 条件];</span><br></pre></td></tr></table></figure><p>注意：</p><p>修改语句的条件可以有，也可以没有，如果没有条件，则会修改整张表的所有数据。</p><h4 id="DML-删除数据"><a href="#DML-删除数据" class="headerlink" title="DML-删除数据"></a>DML-删除数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名 [<span class="keyword">WHERE</span> 条件];</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>DELETE 语句的条件可以有，也可以没有，如果没有条件，则会删除整张表的所有数据。</li><li>DELETE 语句不能删除某一个字段的值(可以使用UPDATE)。</li></ul><h3 id="DQL：数据查询语句"><a href="#DQL：数据查询语句" class="headerlink" title="DQL：数据查询语句"></a>DQL：数据查询语句</h3><h4 id="DQL-语法"><a href="#DQL-语法" class="headerlink" title="DQL-语法"></a>DQL-语法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 编写顺序</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">字段列表 </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">表名列表</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">条件列表</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">分组字段列表</span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line">分组后条件列表</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">排序字段列表</span><br><span class="line">LIMIT</span><br><span class="line">分页参数</span><br></pre></td></tr></table></figure><ul><li>基本查询</li><li>条件查询（WHERE）</li><li>聚合函数（count、max、min、avg、sum）</li><li>分组查询（GROUP BY）</li><li>排序查询（ORDER BY）</li><li>分页查询（LIMIT）</li></ul><h4 id="DQL-基本查询"><a href="#DQL-基本查询" class="headerlink" title="DQL-基本查询"></a>DQL-基本查询</h4><ol><li><p>查询多个字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段<span class="number">1</span>，字段<span class="number">2</span>，字段<span class="number">3.</span>.. <span class="keyword">FROM</span> 表名;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure></li><li><p>设置别名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段<span class="number">1</span> [<span class="keyword">AS</span> 别名<span class="number">1</span>], 字段<span class="number">2</span>  [<span class="keyword">AS</span> 别名<span class="number">2</span>], .....<span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure></li><li><p>去除重复记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 字段列表 <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp(</span><br><span class="line">    id  <span class="type">int</span> comment <span class="string">&#x27;序号&#x27;</span>,</span><br><span class="line">    workno   <span class="type">int</span> comment <span class="string">&#x27;员工编号&#x27;</span>,</span><br><span class="line">    name     <span class="type">varchar</span>(<span class="number">10</span>) comment <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">    gender <span class="type">char</span>(<span class="number">1</span>) comment <span class="string">&#x27;性别&#x27;</span>,</span><br><span class="line">    age <span class="type">int</span> comment <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">    idcard <span class="type">char</span>(<span class="number">16</span>) comment <span class="string">&#x27;身份证号&#x27;</span>,</span><br><span class="line">    workaddress <span class="type">varchar</span>(<span class="number">50</span>) comment <span class="string">&#x27;地址&#x27;</span>,</span><br><span class="line">    entrydate <span class="type">date</span> comment <span class="string">&#x27;入职日期&#x27;</span></span><br><span class="line">)comment <span class="string">&#x27;员工信息表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">desc</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp (id, workno, name, gender, age, idcard, workaddress, entrydate)</span><br><span class="line"><span class="keyword">values</span></span><br><span class="line">    (<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;小红&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;1234567812345678&#x27;</span>,<span class="string">&#x27;北京&#x27;</span>,<span class="string">&#x27;2001-4-2&#x27;</span>),</span><br><span class="line">    (<span class="number">2</span>,<span class="number">2</span>,<span class="string">&#x27;小明&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;1234567812345678&#x27;</span>,<span class="string">&#x27;上海&#x27;</span>,<span class="string">&#x27;2011-10-2&#x27;</span>),</span><br><span class="line">    (<span class="number">3</span>,<span class="number">3</span>,<span class="string">&#x27;小刚&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;1234567812345678&#x27;</span>,<span class="string">&#x27;北京&#x27;</span>,<span class="string">&#x27;2010-3-2&#x27;</span>),</span><br><span class="line">    (<span class="number">4</span>,<span class="number">4</span>,<span class="string">&#x27;小六&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;1234567812345678&#x27;</span>,<span class="string">&#x27;广东&#x27;</span>,<span class="string">&#x27;2005-7-2&#x27;</span>),</span><br><span class="line">    (<span class="number">5</span>,<span class="number">5</span>,<span class="string">&#x27;小非&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;1234567812345678&#x27;</span>,<span class="string">&#x27;北京&#x27;</span>,<span class="string">&#x27;2006-8-2&#x27;</span>),</span><br><span class="line">    (<span class="number">6</span>,<span class="number">6</span>,<span class="string">&#x27;小爱&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;1234567812345678&#x27;</span>,<span class="string">&#x27;福建&#x27;</span>,<span class="string">&#x27;2003-1-2&#x27;</span>),</span><br><span class="line">    (<span class="number">7</span>,<span class="number">7</span>,<span class="string">&#x27;小画&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;1234567812345678&#x27;</span>,<span class="string">&#x27;西安&#x27;</span>,<span class="string">&#x27;2003-3-2&#x27;</span>),</span><br><span class="line">    (<span class="number">8</span>,<span class="number">8</span>,<span class="string">&#x27;小码&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;1234567812345678&#x27;</span>,<span class="string">&#x27;上海&#x27;</span>,<span class="string">&#x27;2004-6-2&#x27;</span>),</span><br><span class="line">    (<span class="number">9</span>,<span class="number">9</span>,<span class="string">&#x27;小洋&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;1234567812345678&#x27;</span>,<span class="string">&#x27;北京&#x27;</span>,<span class="string">&#x27;2005-12-2&#x27;</span>),</span><br><span class="line">    (<span class="number">10</span>,<span class="number">10</span>,<span class="string">&#x27;小紫&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;1234567812345678&#x27;</span>,<span class="string">&#x27;苏州&#x27;</span>,<span class="string">&#x27;2005-3-2&#x27;</span>),</span><br><span class="line">    (<span class="number">11</span>,<span class="number">11</span>,<span class="string">&#x27;小一&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;1234567812345678&#x27;</span>,<span class="string">&#x27;上海&#x27;</span>,<span class="string">&#x27;2001-7-2&#x27;</span>),</span><br><span class="line">    (<span class="number">12</span>,<span class="number">12</span>,<span class="string">&#x27;小时&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;1234567812345678&#x27;</span>,<span class="string">&#x27;江苏&#x27;</span>,<span class="string">&#x27;2007-5-2&#x27;</span>),</span><br><span class="line">    (<span class="number">13</span>,<span class="number">13</span>,<span class="string">&#x27;小五&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;1234567812345678&#x27;</span>,<span class="string">&#x27;北京&#x27;</span>,<span class="string">&#x27;2006-11-2&#x27;</span>),</span><br><span class="line">    (<span class="number">14</span>,<span class="number">14</span>,<span class="string">&#x27;小六&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;1234567812345678&#x27;</span>,<span class="string">&#x27;上海&#x27;</span>,<span class="string">&#x27;2007-1-2&#x27;</span>),</span><br><span class="line">    (<span class="number">15</span>,<span class="number">15</span>,<span class="string">&#x27;小八&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;1234567812345678&#x27;</span>,<span class="string">&#x27;西安&#x27;</span>,<span class="string">&#x27;2007-9-2&#x27;</span>),</span><br><span class="line">    (<span class="number">16</span>,<span class="number">16</span>,<span class="string">&#x27;小破&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;1234567812345678&#x27;</span>,<span class="string">&#x27;天津&#x27;</span>,<span class="string">&#x27;2005-2-2&#x27;</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> emp;</span><br><span class="line"><span class="comment">-- 1.查询指定字段 name workno age</span></span><br><span class="line"><span class="keyword">select</span> name, workno,age <span class="keyword">from</span> emp;</span><br><span class="line"><span class="comment">-- 2.查询所有字段</span></span><br><span class="line"><span class="keyword">select</span> id, workno, name, gender, age, idcard, workaddress, entrydate <span class="keyword">from</span> emp;</span><br><span class="line"><span class="comment">-- 尽量不要用*来查询所有字段</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp;</span><br><span class="line"><span class="comment">-- 3.查询所有员工的工作地址，起别名</span></span><br><span class="line"><span class="keyword">select</span> workaddress <span class="keyword">as</span> <span class="string">&#x27;工作地址&#x27;</span> <span class="keyword">from</span> emp;</span><br><span class="line"><span class="comment">-- as可以省略</span></span><br><span class="line"><span class="keyword">select</span> workaddress  <span class="string">&#x27;工作地址&#x27;</span> <span class="keyword">from</span> emp;</span><br><span class="line"><span class="comment">-- 4. 查询公司员工的上班地址(不要重复)  distinck 过滤重复</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> workaddress <span class="string">&#x27;工作地址&#x27;</span> <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure></li></ol><h4 id="DQL-条件查询"><a href="#DQL-条件查询" class="headerlink" title="DQL-条件查询"></a>DQL-条件查询</h4><ol><li><p>语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件列表;</span><br></pre></td></tr></table></figure></li><li><p>条件</p></li></ol><table><thead><tr><th>比较运算符</th><th>功能</th></tr></thead><tbody><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr><tr><td>&#x3D;</td><td>等于</td></tr><tr><td>&lt;&gt;  或 !&#x3D;</td><td>不等于</td></tr><tr><td>BETWEEN…AND…</td><td>在某个范围之内(含最小、最大值)</td></tr><tr><td>IN(…)</td><td>在in之后的列表中的值，多选一</td></tr><tr><td>LIKE 占位符</td><td>模糊匹配(_匹配单个字符，%匹配任意个字符)</td></tr><tr><td>IS NULL</td><td>是NULL</td></tr></tbody></table><table><thead><tr><th>逻辑运算符</th><th>功能</th></tr></thead><tbody><tr><td>AND 或 &amp;&amp;</td><td>并且（多个条件同时成立）</td></tr><tr><td>OR 或 ||</td><td>或者（多个条件任意一个成立）</td></tr><tr><td>NOT 或 ！</td><td>非，不是</td></tr></tbody></table><h4 id="DQL-聚合函数"><a href="#DQL-聚合函数" class="headerlink" title="DQL-聚合函数"></a>DQL-聚合函数</h4><ol><li><p>介绍</p><p>将一列数据作为一个整体，进行纵向计算</p></li><li><p>常见聚合函数</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>count</td><td>统计数量</td></tr><tr><td>max</td><td>最大值</td></tr><tr><td>min</td><td>最小值</td></tr><tr><td>avg</td><td>平均值</td></tr><tr><td>sum</td><td>求和</td></tr></tbody></table></li><li><p>语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 聚合函数(字段列表) <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure></li></ol><h4 id="DQL-分组查询"><a href="#DQL-分组查询" class="headerlink" title="DQL-分组查询"></a>DQL-分组查询</h4><ol><li><p>语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 [<span class="keyword">WHERE</span> 条件] <span class="keyword">GROUP</span> <span class="keyword">BY</span> 分组字段名 [<span class="keyword">HAVING</span> 分组后过滤条件]</span><br></pre></td></tr></table></figure></li><li><p>where 与 having区别</p><ul><li>执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组之后对结果进行过滤。</li><li>判断条件不同：where不能对聚合函数进行判断，而having可以。</li></ul></li></ol><p>注意</p><ul><li>执行顺序：where &gt; 聚合函数 &gt; having</li><li>分组之后,查询的字段一般为聚合函数和分组字段,查询其他字段无任何意义</li></ul><h4 id="DQL-排序查询"><a href="#DQL-排序查询" class="headerlink" title="DQL-排序查询"></a>DQL-排序查询</h4><ol><li><p>语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 字段<span class="number">1</span> 排序方式<span class="number">1</span> , 字段<span class="number">2</span> 排序方式<span class="number">2</span>;</span><br></pre></td></tr></table></figure></li><li><p>排序方式</p><ul><li>ASC: 升序(默认值)</li><li>DESC: 降序</li></ul><p>注意: 如果是多字段排序,当第一个字段值相同时,才会根据第二个字段进行排序。</p></li></ol><h4 id="DQL-分页查询"><a href="#DQL-分页查询" class="headerlink" title="DQL-分页查询"></a>DQL-分页查询</h4><ol><li><p>语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 LIMIT 起始索引,查询记录数</span><br></pre></td></tr></table></figure><p>注意: </p><ul><li>起始索引从0开始, 起始索引 &#x3D; (查询页码 - 1) * 每页显示记录数</li><li>分页查询是数据库的方言,不同的数据库有不同的实现,MySQL中使用LIMIT</li><li>如果查询的是第一页数据,起始索引可以省略,直接简写为LIMIT 10.</li></ul></li></ol><h4 id="DQL-执行顺序"><a href="#DQL-执行顺序" class="headerlink" title="DQL-执行顺序"></a>DQL-执行顺序</h4><p><img src="https://c2.im5i.com/2022/12/12/RGlF3.png" alt="RGlF3.png"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="https://c2.im5i.com/2022/12/12/RGBpR.png" alt="RGBpR.png"></p><h3 id="DCL：数据控制语句"><a href="#DCL：数据控制语句" class="headerlink" title="DCL：数据控制语句"></a>DCL：数据控制语句</h3><h4 id="DCL-管理用户"><a href="#DCL-管理用户" class="headerlink" title="DCL-管理用户"></a>DCL-管理用户</h4><ol><li><p>查询用户</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">USE mysql;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure></li><li><p>创建用户</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;密码&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>修改用户密码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;新密码&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>删除用户</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure><p>注意: </p><ul><li>主机名可以用通配符 % 通配   (%表示在任意主机都可访问 mysql 服务器)</li><li>这类SQL开发人员操作比较少,主要是DBA(Database Administrator 数据库管理员) 使用</li></ul></li></ol><h4 id="DCL-权限控制"><a href="#DCL-权限控制" class="headerlink" title="DCL-权限控制"></a>DCL-权限控制</h4><ol><li><p>查询权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>授予权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> 权限列表 <span class="keyword">ON</span> 数据库名.表名 <span class="keyword">TO</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>撤销权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> 权限列表 <span class="keyword">ON</span> 数据库名.表名 <span class="keyword">FROM</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure><p>注意:</p><ul><li>多个权限之间，使用逗号分隔</li><li>授权时，数据库名和表名可以使用*进行通配，代表所有</li></ul></li></ol><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><p>MySQL中内置了很多字符串函数，常用的如下：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CONCAT(S1,S2,…..Sn)</td><td>字符串拼接，将S1，S2，….Sn拼接成一个字符串</td></tr><tr><td>LOWER(str)</td><td>将字符串str全部转为小写</td></tr><tr><td>UPPER(str)</td><td>将字符串str全部转为大写</td></tr><tr><td>LPAD(str,n,pad)</td><td>左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</td></tr><tr><td>RPAD(str,n,pad)</td><td>右填充，用字符串pad对str的右边进行填充，达到n个字符串长度</td></tr><tr><td>TRIM(str)</td><td>去掉字符串头部和尾部的空格</td></tr><tr><td>SUBSTRING(str,start,len)</td><td>返回从字符串str从start位置起的len个长度的字符串</td></tr></tbody></table><h3 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h3><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CEIL(x)</td><td>向上取整</td></tr><tr><td>FLOOR(x)</td><td>向下取整</td></tr><tr><td>MOD(x,y)</td><td>返回x&#x2F;y的模</td></tr><tr><td>RAND()</td><td>返回0~1内的随机数</td></tr><tr><td>ROUND(x,y)</td><td>求参数x的四舍五入的值，保留y位小数</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 生成六位验证码</span></span><br><span class="line"><span class="keyword">select</span> rpad( round( rand()<span class="operator">*</span><span class="number">100000</span>,<span class="number">0</span> ) ,<span class="number">6</span>,<span class="string">&#x27;0&#x27;</span>) ;</span><br></pre></td></tr></table></figure><h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CURDATE()</td><td>返回当前日期</td></tr><tr><td>CURTIME()</td><td>返回当前时间</td></tr><tr><td>NOW()</td><td>返回当前日期和时间</td></tr><tr><td>YEAR(date)</td><td>获取指定date的年份</td></tr><tr><td>MONTH(date)</td><td>获取指定date的月份</td></tr><tr><td>DAY(date)</td><td>获取指定date的日期</td></tr><tr><td>DATE_ADD(date,INTERVAL expr type)</td><td>返回一个日期&#x2F;时间值加上一个时间间隔exper后的时间值</td></tr><tr><td>DATEDIFF(date1,date2)</td><td>返回起始时间date1 和 结束时间date2之间的天数</td></tr></tbody></table><h3 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h3><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>IF(value,t,f)</td><td>如果value为true，则返回true，否则返回false</td></tr><tr><td>IFNULL(value1,value2)</td><td>如果value1不为空，返回value1，否则返回value2</td></tr><tr><td>CASE WHEN [val1] THEN [res1] ….. ELSE [default] END</td><td>如果val1为true，返回res1，…. 否则返回default默认值</td></tr><tr><td>CASE [expr] WHEN [val1] THEN [res1] …. ELSE [default] END</td><td>如果expr的值等于val1，返回res1，….. 否则返回default默认值</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 案例:统计班级各个学员的成绩，展示的规则如下：</span></span><br><span class="line"><span class="comment">-- &gt;= 85 展示优秀</span></span><br><span class="line"><span class="comment">-- &gt;= 60 展示及格</span></span><br><span class="line"><span class="comment">-- 否则， 展示不及格</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> Student (</span><br><span class="line">    id <span class="type">varchar</span>(<span class="number">5</span>) comment <span class="string">&#x27;序号&#x27;</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">10</span>) comment <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">    chinese <span class="type">int</span> comment <span class="string">&#x27;语文成绩&#x27;</span>,</span><br><span class="line">    math <span class="type">int</span> comment <span class="string">&#x27;数学成绩&#x27;</span>,</span><br><span class="line">    english <span class="type">int</span> comment <span class="string">&#x27;英语成绩&#x27;</span></span><br><span class="line">) comment <span class="string">&#x27;学生成绩单&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student (id, name, chinese, math, english)</span><br><span class="line"><span class="keyword">value</span> </span><br><span class="line">(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;Allen&#x27;</span>,<span class="number">76</span>,<span class="number">88</span>,<span class="number">66</span>),</span><br><span class="line">(<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;Mikasa&#x27;</span>,<span class="number">52</span>,<span class="number">98</span>,<span class="number">60</span>), </span><br><span class="line">(<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;doinb&#x27;</span>,<span class="number">74</span>,<span class="number">54</span>,<span class="number">44</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方法1 用case when then ...</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">       id,</span><br><span class="line">       name,</span><br><span class="line">       <span class="keyword">case</span>  <span class="keyword">when</span> chinese <span class="operator">&gt;=</span> <span class="number">85</span> <span class="keyword">then</span> <span class="string">&#x27;优秀&#x27;</span> <span class="keyword">when</span> chinese <span class="operator">&gt;=</span> <span class="number">60</span> <span class="keyword">then</span> <span class="string">&#x27;及格&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;不及格&#x27;</span> <span class="keyword">end</span> <span class="keyword">as</span><span class="string">&#x27;语文&#x27;</span>,</span><br><span class="line">       <span class="keyword">case</span>  <span class="keyword">when</span> math <span class="operator">&gt;=</span> <span class="number">85</span> <span class="keyword">then</span> <span class="string">&#x27;优秀&#x27;</span> <span class="keyword">when</span> math <span class="operator">&gt;=</span> <span class="number">60</span> <span class="keyword">then</span> <span class="string">&#x27;及格&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;不及格&#x27;</span>  <span class="keyword">end</span> <span class="keyword">as</span><span class="string">&#x27;数学&#x27;</span>,</span><br><span class="line">       <span class="keyword">case</span>  <span class="keyword">when</span> english <span class="operator">&gt;=</span> <span class="number">85</span> <span class="keyword">then</span> <span class="string">&#x27;优秀&#x27;</span> <span class="keyword">when</span> english <span class="operator">&gt;=</span> <span class="number">60</span> <span class="keyword">then</span> <span class="string">&#x27;及格&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;不及格&#x27;</span> <span class="keyword">end</span> <span class="keyword">as</span><span class="string">&#x27;英语&#x27;</span></span><br><span class="line"><span class="keyword">from</span> student;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方法二 if嵌套</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">    id,</span><br><span class="line">    name,</span><br><span class="line">    if(chinese <span class="operator">&gt;=</span> <span class="number">85</span>,<span class="string">&#x27;优秀&#x27;</span>, if(chinese <span class="operator">&gt;=</span><span class="number">60</span>,<span class="string">&#x27;及格&#x27;</span>,<span class="string">&#x27;不及格&#x27;</span>))<span class="string">&#x27;语文&#x27;</span>,</span><br><span class="line">    if(math <span class="operator">&gt;=</span> <span class="number">85</span>,<span class="string">&#x27;优秀&#x27;</span>, if(math <span class="operator">&gt;=</span><span class="number">60</span>,<span class="string">&#x27;及格&#x27;</span>,<span class="string">&#x27;不及格&#x27;</span>))<span class="string">&#x27;数学&#x27;</span>,</span><br><span class="line">    if(english <span class="operator">&gt;=</span> <span class="number">85</span>,<span class="string">&#x27;优秀&#x27;</span>, if(english <span class="operator">&gt;=</span><span class="number">60</span>,<span class="string">&#x27;及格&#x27;</span>,<span class="string">&#x27;不及格&#x27;</span>))<span class="string">&#x27;英语&#x27;</span></span><br><span class="line"><span class="keyword">from</span> student;</span><br></pre></td></tr></table></figure><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol><li>概念：约束时作用于表中字段上的规则，用于限制内存在表中的数据。</li><li>目的：保证数据库中数据的正确、有效性和完整性。</li><li>分类：</li></ol><table><thead><tr><th>约束</th><th>描述</th><th>关键字</th></tr></thead><tbody><tr><td>非空约束</td><td>限制该字段的数据不能为null</td><td>NOT NULL</td></tr><tr><td>唯一约束</td><td>保证该字段的所有数据都是唯一、不重复的</td><td>UNIQUE</td></tr><tr><td>主键约束</td><td>主键是一行数据的唯一标识，要求非空且唯一</td><td>PRIMARY KEY</td></tr><tr><td>默认约束</td><td>保存数据时，如果未指定该字段的值，则采用默认值</td><td>DEFAULT</td></tr><tr><td>检查约束(8.0.16版本之后)</td><td>保证字段值满足某一个条件</td><td>CHECK</td></tr><tr><td>外键约束</td><td>用来让两张表的数据之间建立连接，保证数据的一致性和完整性</td><td>FOREIGN KEY</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建有约束的用户表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span> (</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment comment <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">unique</span> comment <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">    age <span class="type">int</span> <span class="keyword">check</span>( age <span class="operator">&gt;</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> age <span class="operator">&lt;</span> <span class="number">120</span>) comment <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">    status <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">default</span> <span class="string">&#x27;1&#x27;</span> comment <span class="string">&#x27;状态&#x27;</span>,</span><br><span class="line">    gender <span class="type">varchar</span>(<span class="number">1</span>) comment <span class="string">&#x27;性别&#x27;</span></span><br><span class="line">) comment <span class="string">&#x27;用户表&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><ul><li><p>语法</p><p>添加外键</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">字段名 数据类型,</span><br><span class="line">....</span><br><span class="line">[<span class="keyword">CONSTRAINT</span>] [外键名称] <span class="keyword">FOREIGN</span> KEY (外键字段名) <span class="keyword">REFERENCES</span> 主表 (主表列名)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> 外键名称 <span class="keyword">FOREIGN</span> (外键字段名) <span class="keyword">REFERENCES</span> 主表 (主表列名);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 案例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> dept(</span><br><span class="line">                     id <span class="type">int</span> auto_increment comment <span class="string">&#x27;ID&#x27;</span> <span class="keyword">primary</span> key,</span><br><span class="line">                     name <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;部门名称&#x27;</span></span><br><span class="line">)comment <span class="string">&#x27;部门表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept (id,name) <span class="keyword">value</span> (<span class="number">1</span>,<span class="string">&#x27;研发部&#x27;</span>), (<span class="number">2</span>,<span class="string">&#x27;市场部&#x27;</span>),(<span class="number">3</span>,<span class="string">&#x27;财务部&#x27;</span>),(<span class="number">4</span>,<span class="string">&#x27;销售部&#x27;</span>),(<span class="number">5</span>,<span class="string">&#x27;总经办&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> employee(</span><br><span class="line">    id <span class="type">int</span> auto_increment <span class="keyword">primary</span> key comment <span class="string">&#x27;ID&#x27;</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">    age <span class="type">int</span> comment <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">    job <span class="type">varchar</span>(<span class="number">20</span>) comment <span class="string">&#x27;职位&#x27;</span>,</span><br><span class="line">    salary <span class="type">int</span> comment <span class="string">&#x27;薪资&#x27;</span>,</span><br><span class="line">    entrydate <span class="type">date</span> comment <span class="string">&#x27;入职时间&#x27;</span>,</span><br><span class="line">    managerid <span class="type">int</span> comment <span class="string">&#x27;直属领导ID&#x27;</span>,</span><br><span class="line">    dept_id <span class="type">int</span> comment <span class="string">&#x27;部门ID&#x27;</span></span><br><span class="line">) comment <span class="string">&#x27;员工表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee (id, name, age, job, salary, entrydate, managerid, dept_id)</span><br><span class="line"><span class="keyword">value</span> (<span class="number">1</span>,<span class="string">&#x27;金庸&#x27;</span>,<span class="number">66</span>,<span class="string">&#x27;总裁&#x27;</span>,<span class="number">20000</span>,<span class="string">&#x27;2000-01-01&#x27;</span>,<span class="keyword">null</span>,<span class="number">5</span>),(<span class="number">2</span>,<span class="string">&#x27;张无忌&#x27;</span>,<span class="number">20</span>,<span class="string">&#x27;项目经理&#x27;</span>,<span class="number">12500</span>,<span class="string">&#x27;2005-12-05&#x27;</span>,<span class="number">1</span>,<span class="number">1</span>),</span><br><span class="line">    (<span class="number">3</span>,<span class="string">&#x27;杨逍&#x27;</span>,<span class="number">33</span>,<span class="string">&#x27;开发&#x27;</span>,<span class="number">8400</span>,<span class="string">&#x27;2000-11-03&#x27;</span>,<span class="number">2</span>,<span class="number">1</span>),(<span class="number">4</span>,<span class="string">&#x27;韦一笑&#x27;</span>,<span class="number">48</span>,<span class="string">&#x27;开发&#x27;</span>,<span class="number">11000</span>,<span class="string">&#x27;2002-02-05&#x27;</span>,<span class="number">2</span>,<span class="number">1</span>),</span><br><span class="line">    (<span class="number">5</span>,<span class="string">&#x27;常遇春&#x27;</span>,<span class="number">43</span>,<span class="string">&#x27;开发&#x27;</span>,<span class="number">10500</span>,<span class="string">&#x27;2004-09-07&#x27;</span>,<span class="number">3</span>,<span class="number">1</span>),(<span class="number">6</span>,<span class="string">&#x27;小昭&#x27;</span>,<span class="number">19</span>,<span class="string">&#x27;程序员鼓励师&#x27;</span>,<span class="number">6600</span>,<span class="string">&#x27;2004-10-12&#x27;</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">-- 添加外键</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> employee <span class="keyword">add</span>  <span class="keyword">constraint</span> fk_employee_dept_id <span class="keyword">foreign</span> key (dept_id) <span class="keyword">references</span> dept (id);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除外键</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> employee <span class="keyword">drop</span> <span class="keyword">foreign</span> key fk_employee_dept_id;</span><br></pre></td></tr></table></figure><p>外键约束</p><ul><li><p>删除&#x2F;更新行为</p><p>| 行为        | 说明                                                         |<br>| ———– | ———————————————————— |<br>| NO ACTION   | 当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新。(与RESTIRICT 一致) |<br>| RESTRICT    | 当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新。(与NO ACTIOn 一致) |<br>| CASCADE     | 当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有，则也许删除&#x2F;更新外键在子表中的记录。 |<br>| SET NULl    | 当在父表中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null。(这就要求外键允许取null)。 |<br>| SET DEFAULT | 父表有变更时，子表将外键列设置成一个默认的值(Innodb不支持)   |</p></li><li><p>语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> 外键名称 <span class="keyword">FOREIGN</span> KEY(外键字段) <span class="keyword">REFERENCES</span> 主表名(主表字段名) <span class="keyword">ON</span> <span class="keyword">UPDATE</span> CASCADE <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE;</span><br></pre></td></tr></table></figure></li></ul><p>总结</p><ol><li>非空约束：NOT NULl</li><li>唯一约束：UNIQUE</li><li>主键约束：PRIMARY KEY（自增：AUTO_INCREMENT）</li><li>默认约束：DEFAULT</li><li>检查约束：CHECK</li><li>外键约束：FOREIGN KEY</li></ol></li></ul><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>项目开发中，在进行数据库表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结构，由于业务之间相互关联，所以各个表结构之间也存在着各种联系，基本上分为三种：</p><ul><li>一对多（多对一）</li><li>多对多</li><li>一对多</li></ul><h4 id="一对多（多对一）"><a href="#一对多（多对一）" class="headerlink" title="一对多（多对一）"></a>一对多（多对一）</h4><p>案例：部门与员工的关系</p><p>关系：一个部门对应多个员工，一个员工对应一个部门</p><p>实现：<strong>在多的一方建立外键，指向一的一方的主键</strong></p><p><img src="https://c2.im5i.com/2022/12/14/RPxHL.png" alt="RPxHL.png">            <img src="https://c2.im5i.com/2022/12/14/RP8Lt.png" alt="RP8Lt.png"></p><h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h4><p>案例：学生与课程的关系</p><p>关系：一个学生可以选修多门课程，一门课程也可以供多个学生选择</p><p>实现：<strong>建立第三张中间表，中间表至少包含两个外键，分别管理两方主键</strong></p><p><img src="https://c2.im5i.com/2022/12/14/RPLvq.png" alt="RPLvq.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 多对多--</span></span><br><span class="line"><span class="comment">-- 学生表 --</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(</span><br><span class="line">    id <span class="type">int</span> auto_increment <span class="keyword">primary</span> key comment <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">10</span>) comment <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">    <span class="keyword">no</span> <span class="type">varchar</span>(<span class="number">10</span>) comment <span class="string">&#x27;学号&#x27;</span></span><br><span class="line">)comment <span class="string">&#x27;学生表&#x27;</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student (id, name, <span class="keyword">no</span>) <span class="keyword">value</span></span><br><span class="line">    (<span class="keyword">null</span>,<span class="string">&#x27;黛绮丝&#x27;</span>,<span class="string">&#x27;2000100101&#x27;</span>),(<span class="keyword">null</span>,<span class="string">&#x27;谢逊&#x27;</span>,<span class="string">&#x27;2000100102&#x27;</span>),(<span class="keyword">null</span>,<span class="string">&#x27;殷天正&#x27;</span>,<span class="string">&#x27;2000100103&#x27;</span>),(<span class="keyword">null</span>,<span class="string">&#x27;韦一笑&#x27;</span>,<span class="string">&#x27;2000100104&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 课程表 --</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> course(</span><br><span class="line">    id <span class="type">int</span> auto_increment <span class="keyword">primary</span> key comment <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">10</span>) comment <span class="string">&#x27;课程名称&#x27;</span></span><br><span class="line">) comment <span class="string">&#x27;课程表&#x27;</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> course (id, name) <span class="keyword">value</span></span><br><span class="line">        (<span class="keyword">null</span>,<span class="string">&#x27;java&#x27;</span>),(<span class="keyword">null</span>,<span class="string">&#x27;PHP&#x27;</span>),(<span class="keyword">null</span>,<span class="string">&#x27;MySQL&#x27;</span>),(<span class="keyword">null</span>,<span class="string">&#x27;Hadoop&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 建立中间表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student_course (</span><br><span class="line">    id <span class="type">int</span> auto_increment <span class="keyword">primary</span> key comment <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">    studentid <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;学生ID&#x27;</span>,</span><br><span class="line">    courseid <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;课程ID&#x27;</span>,</span><br><span class="line">    <span class="keyword">constraint</span> fk_studentid <span class="keyword">foreign</span> key (studentid) <span class="keyword">references</span> student (id),</span><br><span class="line">    <span class="keyword">constraint</span> fk_courseid  <span class="keyword">foreign</span> key (courseid) <span class="keyword">references</span> course (id)</span><br><span class="line">)comment <span class="string">&#x27;学生课程中间表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student_course (id, studentid, courseid)  <span class="keyword">value</span></span><br><span class="line">(<span class="keyword">null</span>,<span class="number">1</span>,<span class="number">1</span>),(<span class="keyword">null</span>,<span class="number">1</span>,<span class="number">2</span>),(<span class="keyword">null</span>,<span class="number">1</span>,<span class="number">3</span>),(<span class="keyword">null</span>,<span class="number">2</span>,<span class="number">2</span>),(<span class="keyword">null</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="keyword">null</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p><img src="https://c2.im5i.com/2022/12/14/RPzZs.png" alt="RPzZs.png"></p><h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h4><p>案例：用户与用户详情的关系</p><p>关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率</p><p>实现：在任意一方加入外键，关联另一方的主键，并且设置外键为唯一的（UNIQUE）</p><p><img src="https://c2.im5i.com/2022/12/14/RPDFQ.png" alt="RPDFQ.png"></p><p>​⬇</p><p><img src="https://c2.im5i.com/2022/12/14/RP4Ry.png" alt="RP4Ry.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_user(</span><br><span class="line">    id <span class="type">int</span> auto_increment <span class="keyword">primary</span> key comment <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">10</span>) comment <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">    age <span class="type">int</span> comment <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">    gender <span class="type">char</span>(<span class="number">1</span>) comment <span class="string">&#x27;1：男， 2：女&#x27;</span>,</span><br><span class="line">    phone <span class="type">char</span>(<span class="number">11</span>)  comment <span class="string">&#x27;手机号&#x27;</span></span><br><span class="line">)comment <span class="string">&#x27;用户基本信息表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_user_edu(</span><br><span class="line">    id <span class="type">int</span> auto_increment <span class="keyword">primary</span> key comment <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">    degree <span class="type">varchar</span>(<span class="number">20</span>) comment <span class="string">&#x27;学历&#x27;</span>,</span><br><span class="line">    major <span class="type">varchar</span>(<span class="number">50</span>) comment <span class="string">&#x27;专业&#x27;</span>,</span><br><span class="line">    primaryschool <span class="type">varchar</span>(<span class="number">50</span>) comment <span class="string">&#x27;小学&#x27;</span>,</span><br><span class="line">    middleschool <span class="type">varchar</span>(<span class="number">50</span>) comment <span class="string">&#x27;中学&#x27;</span>,</span><br><span class="line">    university <span class="type">varchar</span>(<span class="number">50</span>) comment <span class="string">&#x27;大学&#x27;</span>,</span><br><span class="line">    userid <span class="type">int</span> <span class="keyword">unique</span> comment <span class="string">&#x27;用户ID&#x27;</span>,</span><br><span class="line">    <span class="keyword">constraint</span> fk_userid <span class="keyword">foreign</span> key (userid) <span class="keyword">references</span> tb_user (id)</span><br><span class="line">)comment <span class="string">&#x27;用户教育信息表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_user (id, name, age, gender, phone) <span class="keyword">value</span></span><br><span class="line">(<span class="keyword">null</span>,<span class="string">&#x27;黄渤&#x27;</span>,<span class="number">45</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;18800001111&#x27;</span>),</span><br><span class="line">(<span class="keyword">null</span>,<span class="string">&#x27;冰冰&#x27;</span>,<span class="number">35</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;18800002222&#x27;</span>),</span><br><span class="line">(<span class="keyword">null</span>,<span class="string">&#x27;码云&#x27;</span>,<span class="number">55</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;18800008888&#x27;</span>),</span><br><span class="line">(<span class="keyword">null</span>,<span class="string">&#x27;李彦宏&#x27;</span>,<span class="number">50</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;18800009999&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_user_edu (id, degree, major, primaryschool, middleschool, university, userid) <span class="keyword">value</span></span><br><span class="line">    (<span class="keyword">null</span>,<span class="string">&#x27;本科&#x27;</span>,<span class="string">&#x27;舞蹈&#x27;</span>,<span class="string">&#x27;静安区第一小学&#x27;</span>,<span class="string">&#x27;静安区第一中学&#x27;</span>,<span class="string">&#x27;北京舞蹈学院&#x27;</span>,<span class="number">1</span>),</span><br><span class="line">    (<span class="keyword">null</span>,<span class="string">&#x27;硕士&#x27;</span>,<span class="string">&#x27;表演&#x27;</span>,<span class="string">&#x27;朝阳区第一小学&#x27;</span>,<span class="string">&#x27;朝阳区第一中学&#x27;</span>,<span class="string">&#x27;北京电影学院&#x27;</span>,<span class="number">2</span>),</span><br><span class="line">    (<span class="keyword">null</span>,<span class="string">&#x27;本科&#x27;</span>,<span class="string">&#x27;英语&#x27;</span>,<span class="string">&#x27;杭州市第一小学&#x27;</span>,<span class="string">&#x27;杭州市第一中学&#x27;</span>,<span class="string">&#x27;杭州师范大学&#x27;</span>,<span class="number">3</span>),</span><br><span class="line">    (<span class="keyword">null</span>,<span class="string">&#x27;本科&#x27;</span>,<span class="string">&#x27;应用数学&#x27;</span>,<span class="string">&#x27;阳泉第一小学&#x27;</span>,<span class="string">&#x27;阳泉区第一中学&#x27;</span>,<span class="string">&#x27;清华大学&#x27;</span>,<span class="number">4</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="多表查询概述"><a href="#多表查询概述" class="headerlink" title="多表查询概述"></a>多表查询概述</h3><ul><li>概述：指从多张表中查询数据</li><li>笛卡尔积：笛卡尔乘积是指在数学中，两个集合A集合 和 B集合的所有组合清空。（在多表查询时，需要消除无效的笛卡尔积）</li></ul><p><img src="https://c2.im5i.com/2022/12/14/RPp4O.png" alt="RPp4O.png"></p><ul><li><p>多表查询的分类</p><p>连接查询</p><ul><li>内连接：相当于查询A、B交集部分数据</li><li>外连接：<ul><li>左外连接：查询左表所有数据，以及两张表交际部分数据</li><li>右外连接：查询右表所有数据，以及两张表交际部分数据</li></ul></li><li>自连接：当前表与自身的连接查询，自连接必须使用表别名</li></ul><p>子查询</p><p><img src="https://c2.im5i.com/2022/12/14/RVqy6.png" alt="RVqy6.png"></p></li></ul><h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><h4 id="隐式内连接"><a href="#隐式内连接" class="headerlink" title="隐式内连接"></a>隐式内连接</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 语法 --</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span>，表<span class="number">2</span> <span class="keyword">WHERE</span> 条件...;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 内连接演示</span></span><br><span class="line"><span class="comment">-- 1. 查询每一个员工的姓名，及关联的部门名称(隐式内连接实现)</span></span><br><span class="line"><span class="comment">-- 表结构：emp , dept</span></span><br><span class="line"><span class="comment">-- 连接条件：emp.dept_id = dept.id</span></span><br><span class="line"><span class="keyword">select</span> emp.name,dept.name <span class="keyword">from</span> emp,dept <span class="keyword">where</span> emp.dept_id <span class="operator">=</span> dept.id;</span><br><span class="line"><span class="comment">-- 起别名 注意：起别名后在访问的时候不可以使用原名限制字段</span></span><br><span class="line"><span class="keyword">select</span> e.name, d.name <span class="keyword">from</span> emp e, dept d <span class="keyword">where</span> e.dept_id <span class="operator">=</span> d.id;</span><br></pre></td></tr></table></figure><h4 id="显式内连接"><a href="#显式内连接" class="headerlink" title="显式内连接"></a>显式内连接</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 语法 --  inner 关键字是可以省略的</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> [<span class="keyword">INNER</span>] <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 连接条件; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 查询每一个员工的姓名，及关联的部门名称(显式内连接实现) --- INNER JOIN ... ON ...</span></span><br><span class="line"><span class="comment">-- 表结构：emp , dept</span></span><br><span class="line"><span class="comment">-- 连接条件：emp.dept_id = dept.id</span></span><br><span class="line"><span class="keyword">select</span> e.name, dept.name <span class="keyword">from</span> emp e <span class="keyword">inner</span> <span class="keyword">join</span> dept d <span class="keyword">on</span> e.dept_id <span class="operator">=</span> d.id; </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><h4 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">LEFT</span> [<span class="keyword">OUTER</span>] <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 条件...;</span><br><span class="line"><span class="comment">-- 相当于查询表1(左表)的所有数据 包含 表1和表2交集部分的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询员工信息和对应的部门名称</span></span><br><span class="line"><span class="keyword">select</span> e.<span class="operator">*</span>,d.name <span class="keyword">from</span> emp e <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> dept d <span class="keyword">on</span> e.managerid <span class="operator">=</span> d.id;</span><br></pre></td></tr></table></figure><h4 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">RIGHT</span> [<span class="keyword">OUTER</span>] <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 条件...；</span><br><span class="line"><span class="comment">-- 相当于查询表2(右表)的所有数据 包含 表1和表2交集部分的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询员工信息和对应的部门名称</span></span><br><span class="line"><span class="keyword">select</span> e.<span class="operator">*</span>,d.name <span class="keyword">from</span> dept d <span class="keyword">right</span> <span class="keyword">outer</span> <span class="keyword">join</span> emp e <span class="keyword">on</span> e.managerid <span class="operator">=</span> d.id;</span><br></pre></td></tr></table></figure><p>小注： 左外连接和右外连接时可以相互转换的，一般开发中用左外连接比较多，右外连接也可以用左外连接来代替。</p><h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表A 别名A <span class="keyword">JOIN</span> 表 A 别名B <span class="keyword">ON</span> 条件...;</span><br><span class="line"><span class="comment">-- 子连接查询，可以是内连接查询，也可以是外连接查询。</span></span><br></pre></td></tr></table></figure><h4 id="联合查询-union，union-all"><a href="#联合查询-union，union-all" class="headerlink" title="联合查询-union，union all"></a>联合查询-union，union all</h4><p>对于union查询，就是把多次查询的结果合并起来，形成一个新的查询结果集。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表A...</span><br><span class="line"><span class="keyword">UNION</span> [<span class="keyword">ALl</span>]</span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表B...</span><br></pre></td></tr></table></figure><p>注意：</p><p>对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致。</p><p>union all 会将全部的数据之间合并在一起，union会对合并之后的数据去重。</p><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><ul><li><p>概念：SQL语句中嵌套SELECT语句，称为嵌套查询，又称子查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> columnl <span class="operator">=</span> (<span class="keyword">SELECT</span> columnl <span class="keyword">FROM</span> t2);</span><br><span class="line"><span class="comment">-- 子查询外部的语句可以是INSERT/UPDATE/DELETE/SELECT的任何一个</span></span><br></pre></td></tr></table></figure></li><li><p>根据子查询结果不同，分为：</p><ul><li>标量子查询（子查询结果为单个值）</li><li>列子查询（子查询结果为一列）</li><li>行子查询（子查询结果为一列）</li><li>表子查询（子查询结果为多行多列）</li></ul></li><li><p>根据子查询位置，分为：WHERE之后、FROM之后、SELECT之后。</p></li></ul><h5 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 标量子查询</span></span><br><span class="line"><span class="comment">-- 1. 查询&quot;销售部&quot;的所有员工信息</span></span><br><span class="line"><span class="comment">-- a. 查询&quot;销售部&quot;部门ID</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;销售部&#x27;</span>;</span><br><span class="line"><span class="comment">-- b. 根据&quot;销售部&quot;部门ID，查询员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="comment">-- 二合一</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;销售部&#x27;</span>);</span><br></pre></td></tr></table></figure><h5 id="列子查询"><a href="#列子查询" class="headerlink" title="列子查询"></a>列子查询</h5><p>子查询返回的结果时一列（可以时多行），这种子查询称为列子查询。</p><p>常用的操作符：IN、NOT IN、ANY、SOME、ALL</p><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>IN</td><td>在指定的集合范围之内，多选一</td></tr><tr><td>NOT IN</td><td>不在指定的集合范围之内</td></tr><tr><td>ANY</td><td>子查询返回列表中，有任意一个满足即可</td></tr><tr><td>SOME</td><td>与ANY等同，使用SOME的地方都可以使用ANY</td></tr><tr><td>ALL</td><td>子查询返回列表的所有值都必须满足</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 2. 查询比财务部所有人工资都高的员工信息</span></span><br><span class="line"><span class="comment">-- a. 查询所有 财务部 人员工资</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;财务部&#x27;</span>l</span><br><span class="line"><span class="keyword">select</span> salary <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;财务部&#x27;</span>);</span><br><span class="line"><span class="comment">-- b. 比 财务部 所有人工资都高的员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="number">8</span> <span class="keyword">from</span> emp <span class="keyword">where</span> salary <span class="operator">&gt;</span> <span class="keyword">all</span> (<span class="keyword">select</span> salary <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;财务部&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 查询比凡发布其中任意一人工资高的员工信息</span></span><br><span class="line"><span class="comment">-- a. 查询研发不所有人工资</span></span><br><span class="line"><span class="keyword">select</span> salary <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;研发部&#x27;</span>);</span><br><span class="line"><span class="comment">-- b. 比研发部其中任意一人工资高的员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> salary <span class="operator">&gt;</span> <span class="keyword">some</span>(<span class="keyword">select</span> salary <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;研发部&#x27;</span>));</span><br></pre></td></tr></table></figure><h5 id="行子查询"><a href="#行子查询" class="headerlink" title="行子查询"></a>行子查询</h5><p>子查询返回的结果时一行（可以是多列），这种查询成为行子查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 行子查询</span></span><br><span class="line"><span class="comment">--1. 查询与 &quot;张无忌&quot; 的薪资及直属领导相同的员工信息;</span></span><br><span class="line"><span class="comment">-- a. 查询 &quot;张无忌&quot; 的薪资及直属领导</span></span><br><span class="line"><span class="keyword">select</span> salary, managerid <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张无忌&#x27;</span>;</span><br><span class="line"><span class="comment">-- b. 查询与 &quot;张无忌&quot; 的薪资及直属领导相同的员工信息;</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> (salary,managerid) <span class="operator">=</span> (<span class="keyword">select</span> salary, managerid <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张无忌&#x27;</span>);</span><br></pre></td></tr></table></figure><h5 id="表子查询"><a href="#表子查询" class="headerlink" title="表子查询"></a>表子查询</h5><p>子查询返回的结果时多行多列，这种查询称为表子查询。</p><p>常用的操作符：IN</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>反射</title>
      <link href="/2022/12/08/%E5%8F%8D%E5%B0%84/"/>
      <url>/2022/12/08/%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><h4 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h4><p>当我们想要调用一个类中对象的另一个方法时， 反射可以在我们不修改源码的情况下，直接去修改配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">       properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;d:\\reflection\\src\\cat.properties&quot;</span>));</span><br><span class="line">       <span class="type">String</span> <span class="variable">classPath</span> <span class="operator">=</span> properties.get(<span class="string">&quot;classPath&quot;</span>).toString();</span><br><span class="line">       System.out.println(classPath);</span><br><span class="line">       <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> properties.get(<span class="string">&quot;method&quot;</span>).toString();</span><br><span class="line">       <span class="comment">//加载类，返回Class类型的对象</span></span><br><span class="line">       <span class="type">Class</span> <span class="variable">aClass</span> <span class="operator">=</span> Class.forName(classPath);</span><br><span class="line">       <span class="comment">//这里得到的是一个对象</span></span><br><span class="line">       <span class="comment">//在jdk9之后被弃用将newInstance()-&gt;getDeclaredConstructor().newInstance()</span></span><br><span class="line">       <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> aClass.newInstance();</span><br><span class="line">       <span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> aClass.getDeclaredConstructor().newInstance();</span><br><span class="line">       System.out.println(o2.getClass());</span><br><span class="line">       <span class="type">Method</span> <span class="variable">method1</span> <span class="operator">=</span> aClass.getMethod(method);</span><br><span class="line">       method1.invoke(o2);</span><br></pre></td></tr></table></figure><p>Java类类getDeclaredConstructors（）方法及示例</p><p>getDeclaredConstructors()方法在java.lang包中可用。</p><p>getDeclaredConstructors()方法用于返回一个Constructor对象数组，该数组指示此Class对象所表示的类定义的构造函数的类型(Constructor可以是public，private，protected或default)。</p><p>getDeclaredConstructors()方法**是一种非静态方法，只能通过类对象访问，如果尝试使用类名称访问该方法，则会收到错误消息。</p><p>getDeclaredConstructors()方法在返回Constructor []**时可能会引发异常。</p><p>SecurityException ：在此异常中，当安全管理器存在时可能会引发此异常。</p><h4 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h4><p>⚪Java Reflection</p><p>1.反射机制允许程序在执行期借助于ReflectionAPI取得任何类的内部信息（比如成员变量，构造器，成员方法等待），并能操作对象的属性及方法。反射在设计模式和框架底层都会用到</p><p>2.加载完类之后，在堆中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象包含了类的完整结构信息。通过这个对象得到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，形象的称之为：反射</p><p><img src="https://pic.imgdb.cn/item/63920a4bb1fccdcd36824be4.png"></p><p>反射相关的主要类</p><ol><li>java.lang.Class：代表一个类，Class对象表示某个类加载后在堆中的对象</li><li>java.lang.reflect.Method：代表类的方法，Method对象表示某个类的方法</li><li>java.lang.reflect.Field：代表类的成员变量，Field对象表示某个类的成员变量</li><li>java.lang.reflect.Constructor：代表类的构造方法，Constructor对象表示构造器</li></ol><p>反射优点和缺点</p><ol><li>有点：可以动态的去创建和使用对象（也就是框架底层额核心），使用灵活，没有反射机制，框架技术就失去底层支撑。</li><li>缺点：使用反射基本是解释执行，对执行速度有影响</li></ol><p>反射调用优化-关闭访问检查</p><ol><li>Method和Field、Constructor对象都有setAccessible()方法</li><li>setAccessible作用是启动和金庸访问安全检测的开关</li><li>参数值为true表示反射的对象在使用是取消访问检查，提高反射的效率。参数值为false则表示反射的对象执行访问检查</li></ol><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol><li>Class也是类，因此也继承Object类</li><li>Class类对象不是new出来的，二十系统创建的</li><li>对于某个类的Class类对象，在内存中只有一份，因为类只加载一次</li><li>每个类的实例都会记得自己是由哪个Class实例所生成</li><li>通过Class可以完整地得到一个类的完整结构，通过一系列API</li><li>Class对象是存放在堆里的</li><li>类的字节码二进制数据，是放在方法区的，有的地方称为类的元数据（包括 方法代码、变量名、方法名、访问权限等等）</li></ol><h4 id="获取Class类对象"><a href="#获取Class类对象" class="headerlink" title="获取Class类对象"></a>获取Class类对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.ClassforName</span></span><br><span class="line">   Class&lt;?&gt; aClass1 = Class.forName(path);</span><br><span class="line">        System.out.println(aClass1);</span><br><span class="line"><span class="comment">// 2.类名.class,应用场景：用于参数传递</span></span><br><span class="line">        Class&lt;Student&gt; aClass2 = Student.class;</span><br><span class="line">        System.out.println(aClass2);</span><br><span class="line"><span class="comment">// 3.通过类的实例对象.getClass()</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">aClass3</span> <span class="operator">=</span> student1.getClass();</span><br><span class="line">        System.out.println(aClass3);</span><br><span class="line"><span class="comment">// 4.通过类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> student1.getClass().getClassLoader();</span><br><span class="line">        Class&lt;?&gt; aClass4 = classLoader.loadClass(path);</span><br><span class="line">        System.out.println(aClass4);</span><br><span class="line"><span class="comment">// 5.基本数据类型 Class cls = 基本数据类型.class</span></span><br><span class="line">Class&lt;Integer&gt; integerClass = <span class="type">int</span>.class;</span><br><span class="line"><span class="comment">// 6.基本数据类型对应的包装类，通过tpye得到Class类对象</span></span><br><span class="line">         Class&lt;Integer&gt; type = Integer.TYPE;</span><br></pre></td></tr></table></figure><h4 id="那些类型有Class对象？"><a href="#那些类型有Class对象？" class="headerlink" title="那些类型有Class对象？"></a>那些类型有Class对象？</h4><ol><li>外部类，成员内部类，静态内部类，局部内部类，匿名内部类</li><li>interface：接口</li><li>数组</li><li>enum：枚举</li><li>annotation：注解</li><li>基本数据类型</li><li>void</li></ol><h4 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h4><ul><li>基本说明</li></ul><p>反射机制是java实现动态语言的关键，也就是通过反射实现类动态加载</p><ol><li>静态加载：编译时加载相关类，如果没有则报错，依赖性太强</li><li>动态加载：运行时加载需要的类，如果运行时不用该类，则不会报错，降低了依赖性</li></ol><ul><li>类加载时机</li></ul><ol><li>当创建对象时（new）&#x2F;&#x2F;静态加载</li><li>当子类被加载时，父类也加载  &#x2F;&#x2F;静态加载</li><li>调用类中的静态成员时 &#x2F;&#x2F;静态加载</li><li>通过反射 &#x2F;&#x2F;动态加载</li></ol><p><img src="https://pic.imgdb.cn/item/63920a8cb1fccdcd3682c662.png"></p><ul><li>加载阶段</li></ul><p>JVM在该阶段主要目的时将字节码从不同的数据源（可能是class文件、也可能时jar包、甚至网路）转化为二进制字节流加载到内存中，并生成一个代表该类的java.lang.Class对象</p><ul><li>连接阶段-验证</li></ul><ol><li>目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全</li><li>包括：文件格式验证（是否以魔数 oxcafebabe开头）、元数据验证、字节码验证和符号应用验证</li><li>可以考虑使用 -Xverify:none参数来关闭大部分的类验证措施，缩短虚拟机类加载的时间（大项目考虑性能时候可以选择关闭）</li></ol><ul><li>连接阶段-准备</li></ul><p>JVM会在该阶段对静态变量，分配内存并初始化（对应数据类型的默认初始值，如0、0L、null、false等）。这些变量所使用的内存都将在方法去中进行分配</p><ul><li>连接阶段-解析</li></ul><ol><li>虚拟机将常量池内的符号引用替换为直接引用的过程</li><li>举例说明<br><img src="https://pic.imgdb.cn/item/63920a90b1fccdcd3682cd02.png"></li></ol><ul><li>Initialization（初始化）</li></ul><ol><li>到初始化阶段，才真正开始执行类中定义的Java程序代码，此阶段是执行<clinit>()方法的过程</li><li><clinit>()方法是由编译器按语句在源文件中出现的顺序，依次自动收集类中的所有静态变量的赋值动作和静态代码块中的语句，并进行合并</li><li>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那摩只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕</li></ol><p><img src="https://pic.imgdb.cn/item/63920a9eb1fccdcd3682ed34.png"></p><h4 id="通过反射获取类的结构信息"><a href="#通过反射获取类的结构信息" class="headerlink" title="通过反射获取类的结构信息"></a>通过反射获取类的结构信息</h4><p><img src="https://pic.imgdb.cn/item/63920aa0b1fccdcd3682f066.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//第一组方法API</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">api_01</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到Class对象</span></span><br><span class="line">        Class&lt;?&gt; personCls = Class.forName(<span class="string">&quot;com.hspedu.reflection.Person&quot;</span>);</span><br><span class="line">        <span class="comment">//getName:获取全类名</span></span><br><span class="line">        System.out.println(personCls.getName());<span class="comment">//com.hspedu.reflection.Person</span></span><br><span class="line">        <span class="comment">//getSimpleName:获取简单类名</span></span><br><span class="line">        System.out.println(personCls.getSimpleName());<span class="comment">//Person</span></span><br><span class="line">        <span class="comment">//getFields:获取所有public修饰的属性，包含本类以及父类的</span></span><br><span class="line">        Field[] fields = personCls.getFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;<span class="comment">//增强for</span></span><br><span class="line">            System.out.println(<span class="string">&quot;本类以及父类的属性=&quot;</span> + field.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getDeclaredFields:获取本类中所有属性</span></span><br><span class="line">        Field[] declaredFields = personCls.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field declaredField : declaredFields) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本类中所有属性=&quot;</span> + declaredField.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getMethods:获取所有public修饰的方法，包含本类以及父类的</span></span><br><span class="line">        Method[] methods = personCls.getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本类以及父类的方法=&quot;</span> + method.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getDeclaredMethods:获取本类中所有方法</span></span><br><span class="line">        Method[] declaredMethods = personCls.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method declaredMethod : declaredMethods) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本类中所有方法=&quot;</span> + declaredMethod.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getConstructors: 获取所有public修饰的构造器，包含本类</span></span><br><span class="line">        Constructor&lt;?&gt;[] constructors = personCls.getConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor&lt;?&gt; constructor : constructors) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本类的构造器=&quot;</span> + constructor.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getDeclaredConstructors:获取本类中所有构造器</span></span><br><span class="line">        Constructor&lt;?&gt;[] declaredConstructors = personCls.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor&lt;?&gt; declaredConstructor : declaredConstructors) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本类中所有构造器=&quot;</span> + declaredConstructor.getName());<span class="comment">//这里老师只是输出名</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getPackage:以Package形式返回 包信息</span></span><br><span class="line">        System.out.println(personCls.getPackage());<span class="comment">//com.hspedu.reflection</span></span><br><span class="line">        <span class="comment">//getSuperClass:以Class形式返回父类信息</span></span><br><span class="line">        Class&lt;?&gt; superclass = personCls.getSuperclass();</span><br><span class="line">        System.out.println(<span class="string">&quot;父类的class对象=&quot;</span> + superclass);<span class="comment">//</span></span><br><span class="line">        <span class="comment">//getInterfaces:以Class[]形式返回接口信息</span></span><br><span class="line">        Class&lt;?&gt;[] interfaces = personCls.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; anInterface : interfaces) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;接口信息=&quot;</span> + anInterface);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getAnnotations:以Annotation[] 形式返回注解信息</span></span><br><span class="line">        Annotation[] annotations = personCls.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;注解信息=&quot;</span> + annotation);<span class="comment">//注解</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String hobby;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IA</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IB</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">IA</span>, IB &#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="type">int</span> age; <span class="comment">// 4 + 8 = 12</span></span><br><span class="line">    String job;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> sal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">double</span> sal)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">m4</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="/2022/12/06/java/"/>
      <url>/2022/12/06/java/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>Java定义了位运算符，应用于整数类型(int)，长整型(long)，短整型(short)，字符型(char)，和字节型(byte)等类型。<br>位运算符作用在所有的位上，并且按位运算。假设a &#x3D; 60，b &#x3D; 13;它们的二进制格式表示将如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">0011</span> <span class="number">1100</span></span><br><span class="line">B = <span class="number">0000</span> <span class="number">1101</span></span><br><span class="line">-----------------</span><br><span class="line">A&amp;B = <span class="number">0000</span> <span class="number">1100</span></span><br><span class="line">A | B = <span class="number">0011</span> <span class="number">1101</span></span><br><span class="line">A ^ B = <span class="number">0011</span> <span class="number">0001</span></span><br><span class="line">~A= <span class="number">1100</span> <span class="number">0011</span></span><br></pre></td></tr></table></figure><p>下表列出了位运算符的基本运算，假设整数变量 A 的值为 60 和变量 B 的值为 13：</p><table><thead><tr><th align="left">操作符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">＆</td><td align="left">如果相对应位都是1，则结果为1，否则为0</td><td align="left">（A＆B），得到12，即0000 1100</td></tr><tr><td align="left">\</td><td align="left"></td><td align="left">如果相对应位都是 0，则结果为 0，否则为 1</td></tr><tr><td align="left">^</td><td align="left">如果相对应位值相同，则结果为0，否则为1</td><td align="left">（A ^ B）得到49，即 0011 0001</td></tr><tr><td align="left">〜</td><td align="left">按位取反运算符翻转操作数的每一位，即0变成1，1变成0。</td><td align="left">（〜A）得到-61，即1100 0011</td></tr><tr><td align="left">&lt;&lt;</td><td align="left">按位左移运算符。左操作数按位左移右操作数指定的位数。</td><td align="left">A &lt;&lt; 2得到240，即 1111 0000</td></tr><tr><td align="left">&gt;&gt;</td><td align="left">按位右移运算符。左操作数按位右移右操作数指定的位数。</td><td align="left">A &gt;&gt; 2得到15即 1111</td></tr><tr><td align="left">&gt;&gt;&gt;</td><td align="left">按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。</td><td align="left">A&gt;&gt;&gt;2得到15即0000 1111</td></tr></tbody></table><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>下面的简单示例程序演示了位运算符。复制并粘贴下面的Java程序并保存为Test.java文件，然后编译并运行这个程序：<br>Test.java 文件代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">60</span>; <span class="comment">/* 60 = 0011 1100 */</span> </span><br><span class="line">     <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">13</span>; <span class="comment">/* 13 = 0000 1101 */</span></span><br><span class="line">     <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">     c = a &amp; b;       <span class="comment">/* 12 = 0000 1100 */</span></span><br><span class="line">     System.out.println(<span class="string">&quot;a &amp; b = &quot;</span> + c );</span><br><span class="line"> </span><br><span class="line">     c = a | b;       <span class="comment">/* 61 = 0011 1101 */</span></span><br><span class="line">     System.out.println(<span class="string">&quot;a | b = &quot;</span> + c );</span><br><span class="line"> </span><br><span class="line">     c = a ^ b;       <span class="comment">/* 49 = 0011 0001 */</span></span><br><span class="line">     System.out.println(<span class="string">&quot;a ^ b = &quot;</span> + c );</span><br><span class="line"> </span><br><span class="line">     c = ~a;          <span class="comment">/*-61 = 1100 0011 */</span></span><br><span class="line">     System.out.println(<span class="string">&quot;~a = &quot;</span> + c );</span><br><span class="line"> </span><br><span class="line">     c = a &lt;&lt; <span class="number">2</span>;     <span class="comment">/* 240 = 1111 0000 */</span></span><br><span class="line">     System.out.println(<span class="string">&quot;a &lt;&lt; 2 = &quot;</span> + c );</span><br><span class="line"> </span><br><span class="line">     c = a &gt;&gt; <span class="number">2</span>;     <span class="comment">/* 15 = 1111 */</span></span><br><span class="line">     System.out.println(<span class="string">&quot;a &gt;&gt; 2  = &quot;</span> + c );</span><br><span class="line">  </span><br><span class="line">     c = a &gt;&gt;&gt; <span class="number">2</span>;     <span class="comment">/* 15 = 0000 1111 */</span></span><br><span class="line">     System.out.println(<span class="string">&quot;a &gt;&gt;&gt; 2 = &quot;</span> + c );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上示例编译运行结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a &amp; b = <span class="number">12</span></span><br><span class="line">a | b = <span class="number">61</span></span><br><span class="line">a ^ b = <span class="number">49</span></span><br><span class="line">~a = -<span class="number">61</span></span><br><span class="line">a &lt;&lt; <span class="number">2</span> = <span class="number">240</span></span><br><span class="line">a &gt;&gt; <span class="number">2</span>  = <span class="number">15</span></span><br><span class="line">a &gt;&gt;&gt; <span class="number">2</span> = <span class="number">15</span></span><br></pre></td></tr></table></figure><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>什么是多态，多态具体体现有哪些？<br><strong>多态：方法或对象具有多种形态，是OOP的第三大特征，是建立在封装和继承基础之上</strong></p><h4 id="多态具体体现："><a href="#多态具体体现：" class="headerlink" title="多态具体体现："></a>多态具体体现：</h4><ol><li><strong>方法多态</strong><ol><li><strong>重载体现多态</strong></li><li><strong>重写体现多态</strong></li></ol></li><li><strong>对象多态</strong><ol><li><strong>对象的编译类型和运行类型可以不一致，编译类型在定义时，就确定，不能变化</strong></li><li><strong>对象的运行类型是可以变化的，可以通过getClass（）来查看运行类型</strong></li><li><strong>编译类型看 &#x3D; 号的左边，运行类型看 &#x3D; 号右边</strong></li></ol></li></ol><h4 id="向上转型调用方法的规则如下："><a href="#向上转型调用方法的规则如下：" class="headerlink" title="向上转型调用方法的规则如下："></a>向上转型调用方法的规则如下：</h4><p><strong>（1）可以调用父类中的所有成员（需遵守访问权限）</strong><br><strong>（2）但是不能调用子类的特有的成员</strong><br><strong>（3）因为在编译阶段，能调用那些成员，是由编译类型决定的</strong><br><strong>（4）最终运行效果看子类（运行类型）的具体实现，即调用方法时，按照从子类（运行类型）开始查找方法</strong></p><h4 id="多态向下转型"><a href="#多态向下转型" class="headerlink" title="多态向下转型"></a>多态向下转型</h4><p><strong>（1）语法：子类类型   引用名&#x3D;（子类类型）父类引用；</strong><br><strong>（2）只能强转父类的引用，不能强转父类的对象</strong><br><strong>（3）要求父类的引用必须只想的是当前目标类型的对象</strong><br><strong>（4）向下转型后，可以调用子类类型中所有的成员</strong><br><img src="C:\Users\99301\AppData\Roaming\Typora\typora-user-images\image-20221101212452407.png" alt="image-20221101212452407"></p><h4 id="多态注意事项和细节讨论"><a href="#多态注意事项和细节讨论" class="headerlink" title="多态注意事项和细节讨论"></a>多态注意事项和细节讨论</h4><p>属性没有重写之说！属性的值看编译类型<br>instanceOf比较操作符，用于判断<strong>对象的运行类型</strong>是否为XX类型或XX类型的子类型</p><h4 id="x3D-x3D-和equals的区别"><a href="#x3D-x3D-和equals的区别" class="headerlink" title="&#x3D;&#x3D;和equals的区别"></a>&#x3D;&#x3D;和equals的区别</h4><p><img src="C:\Users\99301\AppData\Roaming\Typora\typora-user-images\image-20221101212801283.png"></p><h4 id="Java的动态绑定机制（巨重要）"><a href="#Java的动态绑定机制（巨重要）" class="headerlink" title="Java的动态绑定机制（巨重要）"></a>Java的动态绑定机制（巨重要）</h4><ol><li>1.当调用对象方法的时候，该对象会和该对象的<strong>内存地址&#x2F;运行类型</strong>绑定<br>2.当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用</li></ol><h2 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a>hashCode方法</h2><ol><li>1.提高具有哈希结构的容器的效率！</li><li>2.两个引用，如果指向的是同一个对象，则哈希值肯定是一样的！</li><li>3.两个引用，如果指向的是不同对象，则哈希值是不一样的</li><li>4.哈希值主要根据地址号来的！，不能完全将哈希值等价于地址。</li></ol><h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h2><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>默认返回：全类名+@哈希值的十六进制，【查看Object 的 toString方法】子类往往重写toString方法，用于返回对象的属性信息<br>重写toString方法，打印对象或拼接对象时，都会自动调用该对象的toString形式<br>当直接输出一个对象是，toString方法会被默认的调用</p><h2 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h2><p>已废弃</p><h2 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h2><ul><li><strong>断掉调试的快捷键：</strong><br><strong>F7（跳入） F8（跳过） shift + F8（跳出） F9（resume，执行到下一个断点）</strong><br><strong>F7：跳入方法内</strong><br><strong>F8：逐行执行代码</strong><br> <strong>shift + F8：跳出方法</strong></li></ul><h2 id="理解main方法语法"><a href="#理解main方法语法" class="headerlink" title="理解main方法语法"></a>理解main方法语法</h2><p>解释main方法的形式：public static void main（String[] args）{}</p><ol><li><strong>main方法是虚拟机调用</strong></li><li><strong>java虚拟机需要调用类的main()方法，所以方法的访问权限必须是public</strong></li><li><strong>java虚拟机在执行main()方法时不必创建对象，所以该方法必须是static</strong></li><li><strong>该方法接收String 类型的数组参数，该数组中保存执行java命令时传递给所运行的类的参数</strong></li><li><strong>java 执行的程序 参数1 参数2 参数3 ……..</strong></li></ol><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><ol><li><strong>static代码块也叫静态代码块，作用就是对类进行初始化，而且它随着类的加载而执行，并且指挥执行一次。如果是普通代码块，每创建一个对象，就执行。</strong></li><li><strong>类什么时候被加载</strong><br><strong>1.创建对象实例时(new)</strong><br><strong>2.创建子类对象实例，父类也会被加载</strong><br><strong>3.使用类的静态成员时(静态属性，静态方法)</strong></li><li><strong>普通的代码块，在创建对象实例时，会被隐式的调用。</strong><br><strong>被创建一次，就会调用一次。</strong><br><strong>如果只是使用类的静态成员时，普通代码快不会执行。</strong><br><strong>小结</strong></li><li>static代码块时类加载时，执行，只会执行一次</li><li>普通代码快时在创建对象时调用的，创建一次，调用一次</li><li>类加载的3钟情况，需要记住<br><strong>创建一个对象时，在一个类 调用的顺序是：(重点、难点)</strong></li><li>调用静态代码块和静态属性初始化(注意：静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按他们定义的顺序调用)</li><li>调用普通代码块和普通属性的初始化(注意：普通代码和普通属性初始化调用的优先级一样，如果多个普通代码块和多个普通属性初始化，则按定义顺序调用)</li><li>调用构造方法<br><strong>Title:</strong><br><strong>构造器的最前面其实隐含了 super()和调用普通代码块，新写一个类演示（截图+说明）静态相关的代码块，属性初始化，在类加载时，就执行完毕，因此时优先于构造器和普通代码块执行的</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//这里有隐藏的执行要求</span></span><br><span class="line"><span class="comment">//（1）super();</span></span><br><span class="line"><span class="comment">//（2）调用普通代码块</span></span><br><span class="line">System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h2><p><strong>final 可以修饰类、属性、方法和局部变量</strong><br><strong>在某些情况下程序员可能有以下需求，就会用到final</strong></p><ol><li>当不希望被继承时，可以用final修饰</li><li>党部希望父类的某个方法被子类覆盖&#x2F;重写（override），可以用final关键字</li><li>当不希望类的某个属性的值被修改，可以用final修饰</li><li>当不希望某个局部变量被修改，可以使用final修饰<br><strong>final使用注意事项和细节</strong></li><li>final修饰的属性又叫常量，一般用XX_XX_XX离开命名</li><li>final修饰的属性在定义时，必须赋初值，并且以后不能再修改，赋值可以在如下位置之一【选择一个位置赋值即可】</li></ol><p>​①定义时：如public final double TAX_RATE &#x3D; 0.08；</p><p>​②在构造器中</p><p>​③在代码块中</p><p>​3.如果final修饰的属性时静态的，则初始化的位置只能是①定义时，②在静态代码块，不能在构造器中赋值。</p><p>​4.final类不能继承，但是可以实例化对象。</p><p>​5.如果不是final类，但是含有final方法，则该方法虽然不能重写，但是可以被继承。</p><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><h3 id="抽象类的介绍"><a href="#抽象类的介绍" class="headerlink" title="抽象类的介绍"></a>抽象类的介绍</h3><ol><li>用abstract 关键字来修饰一个类时，这个类就是抽象类<br>访问修饰符 abstract 类名{}</li><li>用abstract 关键字来修饰一个方法时，这个方法是抽象方法<br><strong>访问修饰符 abstract 返回类型 方法名（参数列表）；&#x2F;&#x2F;没有方法体</strong></li><li>抽象类的价值更多作用是在于设计，时设计者设计号后，让子类继承并实现抽象类（）</li><li>抽象类，时考官比较爱问的知识点，在框架和设计模式使用较多</li></ol><h3 id="抽象类使用细节和注意事项"><a href="#抽象类使用细节和注意事项" class="headerlink" title="抽象类使用细节和注意事项"></a>抽象类使用细节和注意事项</h3><ol><li>抽象类不能被实例化</li><li>抽象类不一定要包含abstract方法。也就是说，抽象类可以没有abstract方法</li><li>一旦类包含了abstract方法，则这个类必须声明为abstract</li><li>abstract只能修饰类和方法，不能修饰属性和其他的。</li><li>抽象类可以有任意成员【引文抽象类还是类】，比如：非抽象方法、构造器、静态属性等</li><li>抽象方法不能有主题，即不能实现 abstract void aaa（）{ }；</li><li>如果一个类继承了抽象类，则他必须实现抽象类的所有抽象方法，排除它自己也声明为abstract类</li></ol><h3 id="static和abstract为何不能同时出现"><a href="#static和abstract为何不能同时出现" class="headerlink" title="static和abstract为何不能同时出现"></a>static和abstract为何不能同时出现</h3><p>当我们试图使用abstract和static同时修饰一个方法时会发现编译器报错，原因在哪里呢？<br>因为static修饰的方法是静态方法，其可以直接被类所调用。而abstract修饰的方法为抽象方法，即无方法体的方法，不能够被直接调用，需要在子类或实现类中去编写完整的方法处理逻辑后才能使用。</p><h2 id="模板设计模式"><a href="#模板设计模式" class="headerlink" title="模板设计模式"></a>模板设计模式</h2><p>概念：<br>固定的流程已经写好了，变化的流程定义成了抽象方法，被子类重写。<br>模板设计就是一种编码风格，把抽象类看作是一个模板，模板中不能决定的东西定义成抽象方法，让使用模板的去重写抽象方法实现需求<br>简单来说：模板设计就是提前搭建好了一些<a href="https://so.csdn.net/so/search?q=%E6%A1%86%E6%9E%B6&spm=1001.2101.3001.7020">框架</a>，但是更细节的东西需要实现类再去实现<br><a href="https://so.csdn.net/so/search?q=%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F&spm=1001.2101.3001.7020">设计模式</a>（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。<br>使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。</p><p>模板设计模式：</p><p>把抽象类整体就可以看做成一个模板，模板中不能决定的东西定义成抽象方法，让使用模板的类（继承抽象类的类）去重写抽象方法实现需求，模板已经定义了通用结构，使用者只需要关心自己需要实现的功能即可</p><p>模板设计模式的优势：<br>1.只需要关注不同的流程，相同交给父类(模板类)去做。<br>2.解耦：各司其职，一个类只关注自己的事情</p><ul><li>模块化：是解耦这种思维的实现方法方式。</li><li>getter&#x2F;setter就是模块化</li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul><li>基本介绍</li></ul><p>接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，再根据具体情况把这些方法写出来。语法：</p><p>interface 接口名{</p><p>&#x2F;&#x2F;属性</p><p>&#x2F;&#x2F;方法（1.抽象方法 2.默认实现方法 3.静态方法）</p><p>}</p><ul><li>class 类名 implements 接口{</li></ul><p>自己属性；</p><p>自己方法；</p><p>必须实现的接口的抽象方法</p><p>}</p><p>小结：</p><ol><li>在jdk7.0前 接口里的所有方法都没有方法体，即都是抽象方法。</li><li>jdk8.0后接口可以有静态方法，默认方法，也就是说接口中可以有方法的具体实现</li></ol><ul><li><p>注意事项和细节</p><p>1.接口不能被实例化</p><p>2.接口中所有的方法时 public方法，接口中抽象方法，可以不用abstract修饰 图示：</p><p>void aaa();</p><p>实际上是： abstract void aaa();</p><p>3.一个普通类实现接口，就必须将改接口的所有方法都实现。</p><p>4.抽象类实现接口，可以不用实现接口的方法。</p></li></ul><p>​5.一个类同时可以实现多个接口</p><p>​6.接口中的属性，只能是final的，而且是 public static final 修饰符。</p><p>​比如：int a &#x3D; 1；实际上是public static final int a &#x3D; 1;(必须初始化)</p><p>​7.接口中的属性的访问形式：接口名.属性名</p><p>​8.接口不能继承其他的类，但是可以继承多个和别的接口</p><p>interface A extends B，C{}</p><p>​9.接口的修饰符只能是 public 和 默认，这点和类的修饰符是一样的。</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><h3 id="自定义枚举类"><a href="#自定义枚举类" class="headerlink" title="自定义枚举类"></a>自定义枚举类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tataki.main01.Enumeration;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 艾伦</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Enumeration01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//使用</span></span><br><span class="line">        System.out.println(Season.spring);</span><br><span class="line">        System.out.println(Season.summer);</span><br><span class="line">        System.out.println(Season.autumn);</span><br><span class="line">        System.out.println(Season.winter);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">    <span class="comment">//1.构造器私有</span></span><br><span class="line">    <span class="comment">//2.在本类创建一组对象</span></span><br><span class="line">    <span class="comment">//3.对外暴露对象（通过加public static final修饰）</span></span><br><span class="line">    <span class="comment">//4.可以提供get方法，但是不能提供set</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line">    <span class="comment">//public static final String num = &quot;19999&quot;; // 不会导致类加载</span></span><br><span class="line">    <span class="comment">//下面的还是会导致类加载，因为数据类型是Season，并不是普通数据类型比如：String int..</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">spring</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;温暖&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">winter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;东天&quot;</span>,<span class="string">&quot;寒冷&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">summer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;炎热&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">autumn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;凉爽&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String name, String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我又来了喔&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Season&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, desc=&#x27;&quot;</span> + desc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*此处小结</span></span><br><span class="line"><span class="comment">1.static final只有修饰基本数据，才不会造成类加载，其他Interger、对象或者方法还是会加载</span></span><br><span class="line"><span class="comment">2.final修饰对象（引用）只是保证指向不变，但不能保证对象本身b</span></span><br></pre></td></tr></table></figure><p><img src="C:\Users\99301\AppData\Roaming\Typora\typora-user-images\image-20221111211238533.png" alt="image-20221111211238533"></p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><ul><li><h4 id="基本介绍："><a href="#基本介绍：" class="headerlink" title="基本介绍："></a>基本介绍：</h4><ul><li>Collection实现子类可以存放多个元素，每个元素可以是Object</li><li>Collection的实现类，有些可以存放重复的元素，有些不可以</li><li>Collection的实现类，有些是有序的(List)，有些不是有序(Set)</li><li>Collection接口没有直接的实现子类，是通过它的子接口Set 和 List 来实现的</li></ul></li><li><h4 id="接口常用方法："><a href="#接口常用方法：" class="headerlink" title="接口常用方法："></a>接口常用方法：</h4><ul><li><p>add：添加单个元素</p></li><li><p>remove：删除指定元素</p></li><li><p>contains：查找元素是否存在</p></li><li><p>size：获取元素个数</p></li><li><p>isEmpty：判断是否为空</p></li><li><p>clear：清空</p></li><li><p>addAll：添加多个元素</p></li><li><p>containsAll：查找多个元素是否都存在</p></li><li><p>removeAll：删除多个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="comment">//        add:添加单个元素</span></span><br><span class="line">        list.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        list.add(<span class="number">10</span>);<span class="comment">//list.add(new Integer(10))</span></span><br><span class="line">        list.add(<span class="literal">true</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"><span class="comment">//        remove:删除指定元素</span></span><br><span class="line">        <span class="comment">//list.remove(0);//删除第一个元素</span></span><br><span class="line">        list.remove(<span class="literal">true</span>);<span class="comment">//指定删除某个元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"><span class="comment">//        contains:查找元素是否存在</span></span><br><span class="line">        System.out.println(list.contains(<span class="string">&quot;jack&quot;</span>));<span class="comment">//T</span></span><br><span class="line"><span class="comment">//        size:获取元素个数</span></span><br><span class="line">        System.out.println(list.size());<span class="comment">//2</span></span><br><span class="line"><span class="comment">//        isEmpty:判断是否为空</span></span><br><span class="line">        System.out.println(list.isEmpty());<span class="comment">//F</span></span><br><span class="line"><span class="comment">//        clear:清空</span></span><br><span class="line">        list.clear();</span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"><span class="comment">//        addAll:添加多个元素</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list2.add(<span class="string">&quot;红楼梦&quot;</span>);</span><br><span class="line">        list2.add(<span class="string">&quot;三国演义&quot;</span>);</span><br><span class="line">        list.addAll(list2);</span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"><span class="comment">//        containsAll:查找多个元素是否都存在</span></span><br><span class="line">        System.out.println(list.containsAll(list2));<span class="comment">//T</span></span><br><span class="line"><span class="comment">//        removeAll：删除多个元素</span></span><br><span class="line">        list.add(<span class="string">&quot;聊斋&quot;</span>);</span><br><span class="line">        list.removeAll(list2);</span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);<span class="comment">//[聊斋]</span></span><br><span class="line"><span class="comment">//        说明：以ArrayList实现类来演示.</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><ul><li><h4 id="基本介绍：-1"><a href="#基本介绍：-1" class="headerlink" title="基本介绍："></a>基本介绍：</h4><ul><li>List集合类中元素有序（即添加顺序和取出顺序一致）、且可重复</li><li>List集合中的每个元素都有其对应的顺序索引，即支持索引</li><li>List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器元素</li><li>常用： ArrayList、LinkedList、Vector</li></ul></li><li><h4 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a>常用方法：</h4><ul><li><p>void add(int index, Object ele)：在index位置插入ele元素</p></li><li><p>boolean addAll(int index, Collection eles)：从index位置开始将eles中的所有元素添加进来</p></li><li><p>Object get(int index)：获取指定index位置的元素</p></li><li><p>int indexOf(Object obj)：返回obj在集合中首次出现的位置</p></li><li><p>int lastindexOf(Object obj)：返回obj在当前集合中末次出现的位置</p></li><li><p>Object remove(int index)：移除指定index位置的元素，井返回此元素</p></li><li><p>Object set(int index, Object ele)：设置指定index位置的元素为ele，相当于是替换</p></li><li><p>List sublist(int fromlndex, int tolndex)：返回从fromlndex到tolndex位置的子集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list.add(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;贾宝玉&quot;</span>);</span><br><span class="line"><span class="comment">//        void add(int index, Object ele):在index位置插入ele元素</span></span><br><span class="line">        <span class="comment">//在index = 1的位置插入一个对象</span></span><br><span class="line">        list.add(<span class="number">1</span>, <span class="string">&quot;韩顺平&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list2.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        list2.add(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        list.addAll(<span class="number">1</span>, list2);</span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        Object get(int index):获取指定index位置的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        int indexOf(Object obj):返回obj在集合中首次出现的位置</span></span><br><span class="line">        System.out.println(list.indexOf(<span class="string">&quot;tom&quot;</span>));<span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置</span></span><br><span class="line">        list.add(<span class="string">&quot;韩顺平&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line">        System.out.println(list.lastIndexOf(<span class="string">&quot;韩顺平&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//        Object remove(int index):移除指定index位置的元素，并返回此元素</span></span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        Object set(int index, Object ele):设置指定index位置的元素为ele , 相当于是替换.</span></span><br><span class="line">        list.set(<span class="number">1</span>, <span class="string">&quot;玛丽&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合</span></span><br><span class="line">        <span class="comment">// 注意返回的子集合 fromIndex &lt;= subList &lt; toIndex</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">returnlist</span> <span class="operator">=</span> list.subList(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;returnlist=&quot;</span> + returnlist);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><ul><li><h4 id="基本介绍：-2"><a href="#基本介绍：-2" class="headerlink" title="基本介绍："></a>基本介绍：</h4><ul><li><p>lterator对象称为迭代器，主要用于遍历 Collection 集合中的元素</p></li><li><p>实现了Collection接口的集合都有一个iterator()方法，用以返回一个实现了lterator接口的对象，即可以返回一个迭代器</p></li><li><p>lterator 仅用于遍历集合，lterator 本身并不存放对象</p></li><li><p>在调用it.next()方法之前必须要调用it.hasNext()进行检测。若不调用，且下一条记录无效，直接调用it.next()会抛出NoSuchElementException异常</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3833/%E6%88%AA%E5%B1%8F2022-05-24%2017.23.58.jpg" alt="截屏2022-05-24 17.23.58"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionIterator</span> &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;all&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Collection</span> <span class="variable">col</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line">        col.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;三国演义&quot;</span>, <span class="string">&quot;罗贯中&quot;</span>, <span class="number">10.1</span>));</span><br><span class="line">        col.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;小李飞刀&quot;</span>, <span class="string">&quot;古龙&quot;</span>, <span class="number">5.1</span>));</span><br><span class="line">        col.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;红楼梦&quot;</span>, <span class="string">&quot;曹雪芹&quot;</span>, <span class="number">34.6</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println(&quot;col=&quot; + col);</span></span><br><span class="line">        <span class="comment">//现在老师希望能够遍历 col集合</span></span><br><span class="line">        <span class="comment">//1. 先得到 col 对应的 迭代器</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> col.iterator();</span><br><span class="line">        <span class="comment">//2. 使用while循环遍历</span></span><br><span class="line"><span class="comment">//        while (iterator.hasNext()) &#123;//判断是否还有数据</span></span><br><span class="line"><span class="comment">//            //返回下一个元素，类型是Object</span></span><br><span class="line"><span class="comment">//            Object obj = iterator.next();</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;obj=&quot; + obj);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment">//老师教大家一个快捷键，快速生成 while =&gt; itit</span></span><br><span class="line">        <span class="comment">//显示所有的快捷键的的快捷键 ctrl + j</span></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;obj=&quot;</span> + obj);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3. 当退出while循环后 , 这时iterator迭代器，指向最后的元素</span></span><br><span class="line">        <span class="comment">//   iterator.next();//NoSuchElementException</span></span><br><span class="line">        <span class="comment">//4. 如果希望再次遍历，需要重置我们的迭代器</span></span><br><span class="line">        iterator = col.iterator();</span><br><span class="line">        System.out.println(<span class="string">&quot;===第二次遍历===&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;obj=&quot;</span> + obj);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Book</span><span class="params">(String name, String author, <span class="type">double</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.author = author;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAuthor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAuthor</span><span class="params">(String author)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.author = author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(<span class="type">double</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Book&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, author=&#x27;&quot;</span> + author + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, price=&quot;</span> + price +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="for增强循环"><a href="#for增强循环" class="headerlink" title="for增强循环"></a>for增强循环</h4><ul><li><h4 id="基本介绍：-3"><a href="#基本介绍：-3" class="headerlink" title="基本介绍："></a>基本介绍：</h4><p>增强for循环，可以代替iterator迭代器，特点：增强for就是简化版的iterator，本质一样，只能用于遍历集合或数组</p></li><li><h4 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素类型 元素名: 集合名或数组名)&#123;</span><br><span class="line">  访问元素;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="普通遍历循环"><a href="#普通遍历循环" class="headerlink" title="普通遍历循环"></a>普通遍历循环</h4><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><ul><li><h4 id="注意事项和细节："><a href="#注意事项和细节：" class="headerlink" title="注意事项和细节："></a>注意事项和细节：</h4><ol><li>允许所有元素包括null加入</li><li>ArrayList 是由数组来实现数据存储的</li><li>ArrayList 基本等同于Vector，除了 ArrayList是线程不安全（执行效率高），在多线程情况下，不建议使用ArrayList</li></ol></li><li><h4 id="底层结构和源码分析："><a href="#底层结构和源码分析：" class="headerlink" title="底层结构和源码分析："></a>底层结构和源码分析：</h4><ol><li><p>ArrayList中维护了一个Object类型的数组elementData，transient Object[] elementData; </p><p>transient 表示瞬间,短暂的，表示该属性不会被序列化</p></li><li><p>创建ArrayList对象时，如果使用的是无参构造器，则初始elementData容量为0，第1次添加，则扩容elementData为10，如需要再次扩容，则扩容elementData 为1.5倍</p></li><li><p>如果使用的是指定大小的构造器，则初始elementData容量为指定大小，如果需要扩容，则直接扩容elementData为1.5倍</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3833/%E6%88%AA%E5%B1%8F2022-05-25%2011.38.41.jpg" alt="截屏2022-05-25 11.38.41"></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3833/%E6%88%AA%E5%B1%8F2022-05-25%2011.40.06.jpg" alt="截屏2022-05-25 11.40.06"></p></li></ol></li></ul><h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><ul><li><h4 id="注意事项和细节：-1"><a href="#注意事项和细节：-1" class="headerlink" title="注意事项和细节："></a>注意事项和细节：</h4><ol><li>Vector底层是一个对象数组， protected Object[] elementData;</li><li>Vector 是线程同步的，即线程安全，Vector类的操作方法带有synchronized</li></ol></li><li><h4 id="底层机制和源码分析："><a href="#底层机制和源码分析：" class="headerlink" title="底层机制和源码分析："></a>底层机制和源码分析：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Vector_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//无参构造器</span></span><br><span class="line">        <span class="comment">//有参数的构造</span></span><br><span class="line">        <span class="type">Vector</span> <span class="variable">vector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vector</span>(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            vector.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        vector.add(<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;vector=&quot;</span> + vector);</span><br><span class="line">        <span class="comment">//老韩解读源码</span></span><br><span class="line">        <span class="comment">//1. new Vector() 底层</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            public Vector() &#123;</span></span><br><span class="line"><span class="comment">                this(10);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">         补充：如果是  Vector vector = new Vector(8);</span></span><br><span class="line"><span class="comment">            走的方法:</span></span><br><span class="line"><span class="comment">            public Vector(int initialCapacity) &#123;</span></span><br><span class="line"><span class="comment">                this(initialCapacity, 0);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">         2. vector.add(i)</span></span><br><span class="line"><span class="comment">         2.1  //下面这个方法就添加数据到vector集合</span></span><br><span class="line"><span class="comment">            public synchronized boolean add(E e) &#123;</span></span><br><span class="line"><span class="comment">                modCount++;</span></span><br><span class="line"><span class="comment">                ensureCapacityHelper(elementCount + 1);</span></span><br><span class="line"><span class="comment">                elementData[elementCount++] = e;</span></span><br><span class="line"><span class="comment">                return true;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">          2.2  //确定是否需要扩容 条件 ： minCapacity - elementData.length&gt;0</span></span><br><span class="line"><span class="comment">            private void ensureCapacityHelper(int minCapacity) &#123;</span></span><br><span class="line"><span class="comment">                // overflow-conscious code</span></span><br><span class="line"><span class="comment">                if (minCapacity - elementData.length &gt; 0)</span></span><br><span class="line"><span class="comment">                    grow(minCapacity);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">          2.3 //如果 需要的数组大小 不够用，就扩容 , 扩容的算法</span></span><br><span class="line"><span class="comment">              //newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?</span></span><br><span class="line"><span class="comment">              //                             capacityIncrement : oldCapacity);</span></span><br><span class="line"><span class="comment">              //就是扩容两倍.</span></span><br><span class="line"><span class="comment">            private void grow(int minCapacity) &#123;</span></span><br><span class="line"><span class="comment">                // overflow-conscious code</span></span><br><span class="line"><span class="comment">                int oldCapacity = elementData.length;</span></span><br><span class="line"><span class="comment">                int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?</span></span><br><span class="line"><span class="comment">                                                 capacityIncrement : oldCapacity);</span></span><br><span class="line"><span class="comment">                if (newCapacity - minCapacity &lt; 0)</span></span><br><span class="line"><span class="comment">                    newCapacity = minCapacity;</span></span><br><span class="line"><span class="comment">                if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span></span><br><span class="line"><span class="comment">                    newCapacity = hugeCapacity(minCapacity);</span></span><br><span class="line"><span class="comment">                elementData = Arrays.copyOf(elementData, newCapacity);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="ArrayList和Vector："><a href="#ArrayList和Vector：" class="headerlink" title="ArrayList和Vector："></a>ArrayList和Vector：</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3833/%E6%88%AA%E5%B1%8F2022-05-26%2011.43.18.jpg" alt="截屏2022-05-26 11.43.18"></p></li></ul><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><ul><li><h4 id="注意事项和细节：-2"><a href="#注意事项和细节：-2" class="headerlink" title="注意事项和细节："></a>注意事项和细节：</h4><ol><li>LinkedList底层实现了双向链表和双端队列特点</li><li>可以添加任意元素包括null</li><li>线程不安全，没有实现同步</li></ol></li><li><h4 id="底层机制："><a href="#底层机制：" class="headerlink" title="底层机制："></a>底层机制：</h4><ol><li><p>Linkedlist底层维护了一个<strong>双向链表</strong></p></li><li><p>Linkedlist中维护了两个属性first和last分别指向首节点和尾节点</p></li><li><p>每个节点（Node对象），里面又维护了prev、next.item三个属性，其中通过<br>prev指向前一个，通过next指向后一个节点。最终实现双向链表</p></li><li><p>所以LinkedList的元素的添加和删除，不是通过数组完成的，相对来说效率较高</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3833/%E6%88%AA%E5%B1%8F2022-05-26%2019.18.01.jpg" alt="截屏2022-05-26 19.18.01"></p></li></ol></li><li><h4 id="ArrayList和LinkedList："><a href="#ArrayList和LinkedList：" class="headerlink" title="ArrayList和LinkedList："></a>ArrayList和LinkedList：</h4><ol><li><p>如果我们改查的操作多，选择ArrayList</p></li><li><p>如果我们增删的操作多，选择LinkedList</p></li><li><p>一般来说，在程序中，80%-90%都是查询，因此大部分情况下会选择ArrayList</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3833/%E6%88%AA%E5%B1%8F2022-05-26%2019.20.03.jpg" alt="截屏2022-05-26 19.20.03"></p></li></ol></li></ul><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ul><li><h4 id="基本介绍：-4"><a href="#基本介绍：-4" class="headerlink" title="基本介绍："></a>基本介绍：</h4><ul><li>无序（添加和取出的顺序不一致），没有索引</li><li>不允许重复元素，所以最多包含一个null</li><li>JDK API中Set接口的实现类有：<br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3833/%E6%88%AA%E5%B1%8F2022-05-26%2019.21.30.jpg" alt="截屏2022-05-26 19.21.30"></li></ul></li><li><h4 id="常用方法：-1"><a href="#常用方法：-1" class="headerlink" title="常用方法："></a>常用方法：</h4><ul><li><p>add：添加单个元素</p></li><li><p>remove：删除指定元素</p></li><li><p>contains：查找元素是否存在</p></li><li><p>size：获取元素个数</p></li><li><p>isEmpty：判断是否为空</p></li><li><p>clear：清空</p></li><li><p>addAll：添加多个元素</p></li><li><p>containsAll：查找多个元素是否都存在</p></li><li><p>removeAll：删除多个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//老韩解读</span></span><br><span class="line">        <span class="comment">//1. 以Set 接口的实现类 HashSet 来讲解Set 接口的方法</span></span><br><span class="line">        <span class="comment">//2. set 接口的实现类的对象(Set接口对象), 不能存放重复的元素, 可以添加一个null</span></span><br><span class="line">        <span class="comment">//3. set 接口对象存放数据是无序(即添加的顺序和取出的顺序不一致)</span></span><br><span class="line">        <span class="comment">//4. 注意：取出的顺序的顺序虽然不是添加的顺序，但是他的固定.</span></span><br><span class="line">        <span class="type">Set</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">        set.add(<span class="string">&quot;john&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;lucy&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;john&quot;</span>);<span class="comment">//重复</span></span><br><span class="line">        set.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;hsp&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;mary&quot;</span>);</span><br><span class="line">        set.add(<span class="literal">null</span>);<span class="comment">//</span></span><br><span class="line">        set.add(<span class="literal">null</span>);<span class="comment">//再次添加null</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">10</span>;i ++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;set=&quot;</span> + set);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="comment">//方式1： 使用迭代器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;=====使用迭代器====&quot;</span>);</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span>  iterator.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;obj=&quot;</span> + obj);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        set.remove(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式2: 增强for</span></span><br><span class="line">        System.out.println(<span class="string">&quot;=====增强for====&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Object o : set) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;o=&quot;</span> + o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//set 接口对象，不能通过索引来获取</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><h4 id="遍历方式："><a href="#遍历方式：" class="headerlink" title="遍历方式："></a>遍历方式：</h4><ol><li>迭代器</li><li>增强for</li><li><strong>不能使用索引方式获取</strong>（普通遍历循环）</li></ol></li></ul><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><ul><li><h4 id="注意事项和细节：-3"><a href="#注意事项和细节：-3" class="headerlink" title="注意事项和细节："></a>注意事项和细节：</h4><ol><li>Hashset实现了Set接口</li><li>Hashset实际上是HashMap</li><li><strong>可以存放null值，但是只能有一个null</strong></li><li>Hashset不保证元素是有序的,取决于hash后，再确定索引的结果</li><li><strong>不能有重复元素&#x2F;对象</strong></li></ol></li><li><h4 id="底层机制和源码分析：-1"><a href="#底层机制和源码分析：-1" class="headerlink" title="底层机制和源码分析："></a>底层机制和源码分析：</h4><ol><li><p>HashSet 底层是 HashMap</p></li><li><p>添加一个元素时，先得到hash值会转成索引值</p></li><li><p>找到存储数据表table，看这个素引位置是否己经存放的有元素如果没有，直接加入</p></li><li><p>如果有调用equals 比较，如果相同，就放奔添加，如果不相同，则添加到最后</p></li><li><p>在Java8中，如果一条链表的元素个数超过 TREEIFY THRESHOLD（默认是8），井且table的大小＞&#x3D;MIN TREEIFY CAPACITY（默认64)就会进行树化(红黑树）</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3833/%E6%88%AA%E5%B1%8F2022-05-27%2011.48.11.jpg" alt="截屏2022-05-27 11.48.11"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSetSource</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">HashSet</span> <span class="variable">hashSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">        hashSet.add(<span class="string">&quot;java&quot;</span>);<span class="comment">//到此位置，第1次add分析完毕.</span></span><br><span class="line">        hashSet.add(<span class="string">&quot;php&quot;</span>);<span class="comment">//到此位置，第2次add分析完毕</span></span><br><span class="line">        hashSet.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;set=&quot;</span> + hashSet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        HashSet 的源码解读</span></span><br><span class="line"><span class="comment">        1. 执行 HashSet()</span></span><br><span class="line"><span class="comment">            public HashSet() &#123;</span></span><br><span class="line"><span class="comment">                map = new HashMap&lt;&gt;();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        2. 执行 add()</span></span><br><span class="line"><span class="comment">           public boolean add(E e) &#123;//e = &quot;java&quot;</span></span><br><span class="line"><span class="comment">                return map.put(e, PRESENT)==null;//(static) PRESENT = new Object();</span></span><br><span class="line"><span class="comment">           &#125;</span></span><br><span class="line"><span class="comment">         3.执行 put() , 该方法会执行 hash(key) 得到key对应的hash值 算法h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</span></span><br><span class="line"><span class="comment">             public V put(K key, V value) &#123;//key = &quot;java&quot; value = PRESENT 共享</span></span><br><span class="line"><span class="comment">                return putVal(hash(key), key, value, false, true);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">         4.执行 putVal</span></span><br><span class="line"><span class="comment">         final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span></span><br><span class="line"><span class="comment">                   boolean evict) &#123;</span></span><br><span class="line"><span class="comment">                Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //定义了辅助变量</span></span><br><span class="line"><span class="comment">                //table 就是 HashMap 的一个数组，类型是 Node[]</span></span><br><span class="line"><span class="comment">                //if 语句表示如果当前table 是null, 或者 大小=0</span></span><br><span class="line"><span class="comment">                //就是第一次扩容，到16个空间.</span></span><br><span class="line"><span class="comment">                if ((tab = table) == null || (n = tab.length) == 0)</span></span><br><span class="line"><span class="comment">                    n = (tab = resize()).length;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                //(1)根据key，得到hash 去计算该key应该存放到table表的哪个索引位置</span></span><br><span class="line"><span class="comment">                //并把这个位置的对象，赋给 p</span></span><br><span class="line"><span class="comment">                //(2)判断p 是否为null</span></span><br><span class="line"><span class="comment">                //(2.1) 如果p 为null, 表示还没有存放元素, 就创建一个Node (key=&quot;java&quot;,value=PRESENT)</span></span><br><span class="line"><span class="comment">                //(2.2) 就放在该位置 tab[i] = newNode(hash, key, value, null)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                if ((p = tab[i = (n - 1) &amp; hash]) == null)</span></span><br><span class="line"><span class="comment">                    tab[i] = newNode(hash, key, value, null);</span></span><br><span class="line"><span class="comment">                else &#123;</span></span><br><span class="line"><span class="comment">                    //一个开发技巧提示： 在需要局部变量(辅助变量)时候，在创建</span></span><br><span class="line"><span class="comment">                    Node&lt;K,V&gt; e; K k; //</span></span><br><span class="line"><span class="comment">                    //如果当前索引位置对应的链表的第一个元素和准备添加的key的hash值一样</span></span><br><span class="line"><span class="comment">                    //并且满足 下面两个条件之一:</span></span><br><span class="line"><span class="comment">                    //(1) 准备加入的key 和 p 指向的Node 结点的 key 是同一个对象</span></span><br><span class="line"><span class="comment">                    //(2)  p 指向的Node 结点的 key 的equals() 和准备加入的key比较后相同</span></span><br><span class="line"><span class="comment">                    //就不能加入</span></span><br><span class="line"><span class="comment">                    if (p.hash == hash &amp;&amp;</span></span><br><span class="line"><span class="comment">                        ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span></span><br><span class="line"><span class="comment">                        e = p;</span></span><br><span class="line"><span class="comment">                    //再判断 p 是不是一颗红黑树,</span></span><br><span class="line"><span class="comment">                    //如果是一颗红黑树，就调用 putTreeVal , 来进行添加</span></span><br><span class="line"><span class="comment">                    else if (p instanceof TreeNode)</span></span><br><span class="line"><span class="comment">                        e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span></span><br><span class="line"><span class="comment">                    else &#123;//如果table对应索引位置，已经是一个链表, 就使用for循环比较</span></span><br><span class="line"><span class="comment">                    </span></span><br><span class="line"><span class="comment">                          //(1) 依次和该链表的每一个元素比较后，都不相同, 则加入到该链表的最后</span></span><br><span class="line"><span class="comment">                          //    注意在把元素添加到链表后，立即判断 该链表是否已经达到8个结点</span></span><br><span class="line"><span class="comment">                          //    , 就调用 treeifyBin() 对当前这个链表进行树化(转成红黑树)</span></span><br><span class="line"><span class="comment">                          //    注意，在转成红黑树时，要进行判断, 判断条件</span></span><br><span class="line"><span class="comment">                          //    if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY(64))</span></span><br><span class="line"><span class="comment">                          //            resize();</span></span><br><span class="line"><span class="comment">                          //    如果上面条件成立，先table扩容.</span></span><br><span class="line"><span class="comment">                          //    只有上面条件不成立时，才进行转成红黑树</span></span><br><span class="line"><span class="comment">                          //(2) 依次和该链表的每一个元素比较过程中，如果有相同情况,就直接break</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                        for (int binCount = 0; ; ++binCount) &#123;</span></span><br><span class="line"><span class="comment">                            if ((e = p.next) == null) &#123;</span></span><br><span class="line"><span class="comment">                                p.next = newNode(hash, key, value, null);</span></span><br><span class="line"><span class="comment">                                if (binCount &gt;= TREEIFY_THRESHOLD(8) - 1) // -1 for 1st</span></span><br><span class="line"><span class="comment">                                    treeifyBin(tab, hash);</span></span><br><span class="line"><span class="comment">                                break;</span></span><br><span class="line"><span class="comment">                            &#125;</span></span><br><span class="line"><span class="comment">                            if (e.hash == hash &amp;&amp;</span></span><br><span class="line"><span class="comment">                                ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span></span><br><span class="line"><span class="comment">                                break;</span></span><br><span class="line"><span class="comment">                            p = e;</span></span><br><span class="line"><span class="comment">                        &#125;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                    if (e != null) &#123; // existing mapping for key</span></span><br><span class="line"><span class="comment">                        V oldValue = e.value;</span></span><br><span class="line"><span class="comment">                        if (!onlyIfAbsent || oldValue == null)</span></span><br><span class="line"><span class="comment">                            e.value = value;</span></span><br><span class="line"><span class="comment">                        afterNodeAccess(e);</span></span><br><span class="line"><span class="comment">                        return oldValue;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                ++modCount;</span></span><br><span class="line"><span class="comment">                //size 就是我们每加入一个结点Node(k,v,h,next), size++</span></span><br><span class="line"><span class="comment">                if (++size &gt; threshold)</span></span><br><span class="line"><span class="comment">                    resize();//扩容</span></span><br><span class="line"><span class="comment">                afterNodeInsertion(evict);</span></span><br><span class="line"><span class="comment">                return null;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><h4 id="扩容和红黑树机制："><a href="#扩容和红黑树机制：" class="headerlink" title="扩容和红黑树机制："></a>扩容和红黑树机制：</h4><ol><li>HashSet底层是HashMap</li><li>第一次添加时，table 数组扩容到 16，临界值(threshold)是 16*加载因子(loadFactor)是0.75&#x3D; 12</li><li>每加入一个节点，size就会++，到达临界值就会扩容</li><li>如果table 数组使用到了临界值 12,就会扩容到16*2&#x3D;32,新的临界值就是32*0.75&#x3D;24，依次类推</li><li>在Java8中，如果一条链表的元素个数到达 TREEIFY_ THRESHOLD(默认是 8）井且table的大小＞&#x3D;MIN TREEIFY CAPACITY (默认64),就会进行树化(红黑树），否则仍然采用数组扩容机制</li></ol></li><li><h4 id="去重机制对比："><a href="#去重机制对比：" class="headerlink" title="去重机制对比："></a>去重机制对比：</h4><ul><li>HashSet去重机制: hashCode() + equals()，底层先通过存入对象，通过运算hash值得到对应的索引，如果table索引所在的位置没有数据就直接存放；如果有数据就进行<strong>equals</strong>（注意重写情况）比较[遍历比较]，如果比较后，不相同就加入，否则就不加入</li><li>TreeSet的去重机制：如果你传入了一个Comparator匿名对象，就使用实现的compare去重，如果方法返回0,就是相同的元素&#x2F;数据，就不添加，如果你没有传入一个Comparator匿名对象，则以你添加的对象实现的Compareable接口的compareTo去重</li></ul></li><li><h4 id="例："><a href="#例：" class="headerlink" title="例："></a>例：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Homework06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();<span class="comment">//ok</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>,<span class="string">&quot;AA&quot;</span>);<span class="comment">//ok</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1002</span>,<span class="string">&quot;BB&quot;</span>);<span class="comment">//ok</span></span><br><span class="line">        set.add(p1);<span class="comment">//ok</span></span><br><span class="line">        set.add(p2);<span class="comment">//ok</span></span><br><span class="line">        p1.name = <span class="string">&quot;CC&quot;</span>;</span><br><span class="line">        set.remove(p1);</span><br><span class="line">        System.out.println(set);<span class="comment">//2</span></span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>,<span class="string">&quot;CC&quot;</span>));</span><br><span class="line">        System.out.println(set);<span class="comment">//3</span></span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>,<span class="string">&quot;AA&quot;</span>));</span><br><span class="line">        System.out.println(set);<span class="comment">//4</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) o;</span><br><span class="line">        <span class="keyword">return</span> id == person.id &amp;&amp;</span><br><span class="line">                Objects.equals(name, person.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3833/%E6%88%AA%E5%B1%8F2022-05-30%2011.03.03.jpg" alt="截屏2022-05-30 11.03.03"></p></li></ul><h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><ul><li><h4 id="注意事项和细节：-4"><a href="#注意事项和细节：-4" class="headerlink" title="注意事项和细节："></a>注意事项和细节：</h4><ol><li><p>LinkedHashset 是Hashset 的子类</p></li><li><p>LinkedHashSet 底层是一个 LinkedHashMap，底层维护了一个 数组＋<strong>双向链表</strong></p></li><li><p>LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置，同时使用链表维护元素的次序(图)，这使得元素看起来是以插入顺序保存的</p></li><li><p>LinkedHashSet 不允许添重复元素</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3833/%E6%88%AA%E5%B1%8F2022-05-29%2016.49.06.jpg" alt="截屏2022-05-29 16.49.06"></p></li></ol></li><li><h4 id="底层机制和源代码分析："><a href="#底层机制和源代码分析：" class="headerlink" title="底层机制和源代码分析："></a>底层机制和源代码分析：</h4><ol><li>LinkedHashSet 加入顺序和取出元素&#x2F;数据的顺序一致</li><li>LinkedHashSet 底层维护的是一个LinkedHashMap(是HashMap的子类)</li><li>LinkedHashSet 底层结构 (数组table+双向链表)</li><li>添加第一次时，直接将 数组table 扩容到 16 ,存放的结点类型是 LinkedHashMap$Entry</li><li>数组是 HashMap$Node[] 存放的元素&#x2F;数据是 LinkedHashMap$Entry类型</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashSetSource</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//分析一下LinkedHashSet的底层机制</span></span><br><span class="line">        <span class="type">Set</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>();</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;AA&quot;</span>));</span><br><span class="line">        set.add(<span class="number">456</span>);</span><br><span class="line">        set.add(<span class="number">456</span>);</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">Customer</span>(<span class="string">&quot;刘&quot;</span>, <span class="number">1001</span>));</span><br><span class="line">        set.add(<span class="number">123</span>);</span><br><span class="line">        set.add(<span class="string">&quot;HSP&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;set=&quot;</span> + set);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1. LinkedHashSet 加入顺序和取出元素/数据的顺序一致</span></span><br><span class="line">        <span class="comment">//2. LinkedHashSet 底层维护的是一个LinkedHashMap(是HashMap的子类)</span></span><br><span class="line">        <span class="comment">//3. LinkedHashSet 底层结构 (数组table+双向链表)</span></span><br><span class="line">        <span class="comment">//4. 添加第一次时，直接将 数组table 扩容到 16 ,存放的结点类型是 LinkedHashMap$Entry</span></span><br><span class="line">        <span class="comment">//5. 数组是 HashMap$Node[] 存放的元素/数据是 LinkedHashMap$Entry类型</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                //继承关系是在内部类完成.</span></span><br><span class="line"><span class="comment">                static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;</span></span><br><span class="line"><span class="comment">                    Entry&lt;K,V&gt; before, after;</span></span><br><span class="line"><span class="comment">                    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span></span><br><span class="line"><span class="comment">                        super(hash, key, value, next);</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> no;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">(String name, <span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><ul><li><h4 id="底层机制：-1"><a href="#底层机制：-1" class="headerlink" title="底层机制："></a>底层机制：</h4><ol><li><p>TreeSet()构造器需传入Comparator接口的匿名内部类，因为底层 Comparable&lt;? super K&gt; k &#x3D; (Comparator&lt;? super K&gt;) key;</p><p>若没有传入，则需要把传入的类实现Comparable接口</p></li><li><p>若按照compare方法比较value相同则无法加入value</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSet_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 当我们使用无参构造器，创建TreeSet时，默认按字母排序</span></span><br><span class="line">        <span class="comment">//2. 老师希望添加的元素，按照字符串大小来排序</span></span><br><span class="line">        <span class="comment">//3. 使用TreeSet 提供的一个构造器，可以传入一个比较器(匿名内部类)</span></span><br><span class="line">        <span class="comment">//   并指定排序规则</span></span><br><span class="line">        <span class="comment">//4. 简单看看源码</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1. 构造器把传入的比较器对象，赋给了 TreeSet的底层的 TreeMap的属性this.comparator</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         public TreeMap(Comparator&lt;? super K&gt; comparator) &#123;</span></span><br><span class="line"><span class="comment">                this.comparator = comparator;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">         2. 在 调用 treeSet.add(&quot;tom&quot;), 在底层会执行到</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">             if (cpr != null) &#123;//cpr 就是我们的匿名内部类(对象)</span></span><br><span class="line"><span class="comment">                do &#123;</span></span><br><span class="line"><span class="comment">                    parent = t;</span></span><br><span class="line"><span class="comment">                    //动态绑定到我们的匿名内部类(对象)compare</span></span><br><span class="line"><span class="comment">                    cmp = cpr.compare(key, t.key);</span></span><br><span class="line"><span class="comment">                    if (cmp &lt; 0)</span></span><br><span class="line"><span class="comment">                        t = t.left;</span></span><br><span class="line"><span class="comment">                    else if (cmp &gt; 0)</span></span><br><span class="line"><span class="comment">                        t = t.right;</span></span><br><span class="line"><span class="comment">                    else //如果相等，即返回0,这个Key就没有加入</span></span><br><span class="line"><span class="comment">                        return t.setValue(value);</span></span><br><span class="line"><span class="comment">                &#125; while (t != null);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        TreeSet treeSet = new TreeSet();</span></span><br><span class="line">        <span class="type">TreeSet</span> <span class="variable">treeSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>(<span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">                <span class="comment">//下面 调用String的 compareTo方法进行字符串大小比较</span></span><br><span class="line">                <span class="comment">//如果老韩要求加入的元素，按照长度大小排序</span></span><br><span class="line">                <span class="comment">//return ((String) o2).compareTo((String) o1);</span></span><br><span class="line">                <span class="keyword">return</span> ((String) o1).length() - ((String) o2).length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//添加数据.</span></span><br><span class="line">        treeSet.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;tom&quot;</span>);<span class="comment">//3</span></span><br><span class="line">        treeSet.add(<span class="string">&quot;sp&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;abc&quot;</span>);<span class="comment">//3</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;treeSet=&quot;</span> + treeSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul><li><h4 id="注意事项和细节：-5"><a href="#注意事项和细节：-5" class="headerlink" title="注意事项和细节："></a>注意事项和细节：</h4><ol><li><p>Map与Collection井列存在，用于保存具有映射关系的数据</p></li><li><p><strong>Map 中的key 和 value 可以是任何引用类型的数据，会封装到HashMap$Node对象中</strong></p></li><li><p>Map 中的key 不允许重复，原因和HashSet 一样</p></li><li><p>Map 中的value 可以重复</p></li><li><p>Map 的key可以为null，value也可以为null，key为null只有能有一个，value为null可以为多个</p></li><li><p>常用String类作为Map的key</p></li><li><p>key 和 value 之间存在单向一对一关系，即通过指定的 key 总能找到对应的 value</p></li><li><p>Map存放数据的key-value示意图，一对 k-y是放在一个Node中的，有因为Node 实现了 Entry 接口</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3833/%E6%88%AA%E5%B1%8F2022-05-27%2023.07.17.jpg" alt="截屏2022-05-27 23.07.17"></p></li></ol></li><li><h4 id="常用方法：-2"><a href="#常用方法：-2" class="headerlink" title="常用方法："></a>常用方法：</h4><ul><li><p>put：添加</p></li><li><p>remove：根据键删除映射关系</p></li><li><p>get：根据键获取值</p></li><li><p>size：获取元素个数</p></li><li><p>isEmpty：判断个数是否为0</p></li><li><p>clear：清除</p></li><li><p>containskey：查找键是否存在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//演示map接口常用方法</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;邓超&quot;</span>, <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;&quot;</span>, <span class="number">100</span>));<span class="comment">//OK</span></span><br><span class="line">        map.put(<span class="string">&quot;邓超&quot;</span>, <span class="string">&quot;孙俪&quot;</span>);<span class="comment">//替换-&gt; 一会分析源码</span></span><br><span class="line">        map.put(<span class="string">&quot;王宝强&quot;</span>, <span class="string">&quot;马蓉&quot;</span>);<span class="comment">//OK</span></span><br><span class="line">        map.put(<span class="string">&quot;宋喆&quot;</span>, <span class="string">&quot;马蓉&quot;</span>);<span class="comment">//OK</span></span><br><span class="line">        map.put(<span class="string">&quot;刘令博&quot;</span>, <span class="literal">null</span>);<span class="comment">//OK</span></span><br><span class="line">        map.put(<span class="literal">null</span>, <span class="string">&quot;刘亦菲&quot;</span>);<span class="comment">//OK</span></span><br><span class="line">        map.put(<span class="string">&quot;鹿晗&quot;</span>, <span class="string">&quot;关晓彤&quot;</span>);<span class="comment">//OK</span></span><br><span class="line">        map.put(<span class="string">&quot;hsp&quot;</span>, <span class="string">&quot;hsp的老婆&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;map=&quot;</span> + map);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        remove:根据键删除映射关系</span></span><br><span class="line">        map.remove(<span class="literal">null</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;map=&quot;</span> + map);</span><br><span class="line"><span class="comment">//        get：根据键获取值</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">val</span> <span class="operator">=</span> map.get(<span class="string">&quot;鹿晗&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;val=&quot;</span> + val);</span><br><span class="line"><span class="comment">//        size:获取元素个数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;k-v=&quot;</span> + map.size());</span><br><span class="line"><span class="comment">//        isEmpty:判断个数是否为0</span></span><br><span class="line">        System.out.println(map.isEmpty());<span class="comment">//F</span></span><br><span class="line"><span class="comment">//        clear:清除k-v</span></span><br><span class="line">        <span class="comment">//map.clear();</span></span><br><span class="line">        System.out.println(<span class="string">&quot;map=&quot;</span> + map);</span><br><span class="line"><span class="comment">//        containsKey:查找键是否存在</span></span><br><span class="line">        System.out.println(<span class="string">&quot;结果=&quot;</span> + map.containsKey(<span class="string">&quot;hsp&quot;</span>));<span class="comment">//T</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Book</span><span class="params">(String name, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><h4 id="遍历方式：-1"><a href="#遍历方式：-1" class="headerlink" title="遍历方式："></a>遍历方式：</h4><ol><li><p>先取出 所有的Key , 通过Key 取出对应的Value</p></li><li><p>把所有的values取出</p></li><li><p>通过 EntrySet 来获取 k-v</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapFor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;邓超&quot;</span>, <span class="string">&quot;孙俪&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;王宝强&quot;</span>, <span class="string">&quot;马蓉&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;宋喆&quot;</span>, <span class="string">&quot;马蓉&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;刘令博&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        map.put(<span class="literal">null</span>, <span class="string">&quot;刘亦菲&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;鹿晗&quot;</span>, <span class="string">&quot;关晓彤&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一组: 先取出 所有的Key , 通过Key 取出对应的Value</span></span><br><span class="line">        <span class="type">Set</span> <span class="variable">keyset</span> <span class="operator">=</span> map.keySet();</span><br><span class="line">        <span class="comment">//(1) 增强for</span></span><br><span class="line">        System.out.println(<span class="string">&quot;---第一种方式-------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object key : keyset) &#123;</span><br><span class="line">            System.out.println(key + <span class="string">&quot;-&quot;</span> + map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//(2) 迭代器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----第二种方式--------&quot;</span>);</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> keyset.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span>  iterator.next();</span><br><span class="line">            System.out.println(key + <span class="string">&quot;-&quot;</span> + map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二组: 把所有的values取出</span></span><br><span class="line">        <span class="type">Collection</span> <span class="variable">values</span> <span class="operator">=</span> map.values();</span><br><span class="line">        <span class="comment">//这里可以使用所有的Collections使用的遍历方法</span></span><br><span class="line">        <span class="comment">//(1) 增强for</span></span><br><span class="line">        System.out.println(<span class="string">&quot;---取出所有的value 增强for----&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object value : values) &#123;</span><br><span class="line">            System.out.println(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//(2) 迭代器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;---取出所有的value 迭代器----&quot;</span>);</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator2</span> <span class="operator">=</span> values.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator2.hasNext()) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span>  iterator2.next();</span><br><span class="line">            System.out.println(value);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三组: 通过EntrySet 来获取 k-v</span></span><br><span class="line">        <span class="type">Set</span> <span class="variable">entrySet</span> <span class="operator">=</span> map.entrySet();<span class="comment">// EntrySet&lt;Map.Entry&lt;K,V&gt;&gt;</span></span><br><span class="line">        <span class="comment">//(1) 增强for</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----使用EntrySet 的 for增强(第3种)----&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object entry : entrySet) &#123;</span><br><span class="line">            <span class="comment">//将entry 转成 Map.Entry</span></span><br><span class="line">            Map.<span class="type">Entry</span> <span class="variable">m</span> <span class="operator">=</span> (Map.Entry) entry;</span><br><span class="line">            System.out.println(m.getKey() + <span class="string">&quot;-&quot;</span> + m.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//(2) 迭代器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----使用EntrySet 的 迭代器(第4种)----&quot;</span>);</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator3</span> <span class="operator">=</span> entrySet.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator3.hasNext()) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">entry</span> <span class="operator">=</span>  iterator3.next();</span><br><span class="line">            <span class="comment">//System.out.println(next.getClass());//HashMap$Node -实现-&gt; Map.Entry (getKey,getValue)</span></span><br><span class="line">            <span class="comment">//向下转型 Map.Entry</span></span><br><span class="line">            Map.<span class="type">Entry</span> <span class="variable">m</span> <span class="operator">=</span> (Map.Entry) entry;</span><br><span class="line">            System.out.println(m.getKey() + <span class="string">&quot;-&quot;</span> + m.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><ul><li><h4 id="注意事项和细节：-6"><a href="#注意事项和细节：-6" class="headerlink" title="注意事项和细节："></a>注意事项和细节：</h4><ol><li>HashMap是Map 接口使用频率最高的实现类</li><li>Hashap 是以 key-val 对的方式来存储数据(HashMap$Node类型）</li><li><strong>key 不能重复，但是值可以重复，允许使用null和null值</strong></li><li><strong>如果添加相同的key，则会覆盖原来的key-val ，等同于修改（key不会替换，val会替换）</strong></li><li>与HashSet一样，不保证映射的顺序，因为底层是以hash表的方式来存储的(jdk8的hashMap 底层 数组＋链表＋红黑树）</li><li>HashMap没有实现同步，因此是线程不安全的，方法没有做同步互斥的操作，没有synchronized</li></ol></li><li><h4 id="底层机制和源码剖析："><a href="#底层机制和源码剖析：" class="headerlink" title="底层机制和源码剖析："></a>底层机制和源码剖析：</h4><ol><li>扩容机制和Hashset相同</li><li>HashMap底层维护了Node类型的数组table，默认为null</li><li>当创建对象时，将加载因子(loadfactor)初始化为0.75</li><li>当添加key-val时，通过key的哈希值得到在table的索引。然后判断该索引处是否有元素，如果没有元素直接添加。如果该索引处有元素，继续判断该元素的key是否和准备加入的key相等，如果相等，则直接替换val：如果不相等需要判断是树结构还是链表结构，做出相应处理。如果添加时发现容量不够，则需要扩容</li><li>第1次添加，则需要扩容table容量为16，临界值(threshold)为12</li><li>以后再扩容，则需要扩容table容量为原来的2倍，临界值为原来的2倍,即24，依次类推</li><li>在Java8中，如果一条链表的元素个数超过 TREEIFY THRESHOLD（默认是8），并且<br>table的大小＞&#x3D;MIN TREEIFY CAPACITY（默认64),就会进行树化（红黑树）</li></ol><p><img src="C:\Users\99301\AppData\Roaming\Typora\typora-user-images\image-20221205234933740.png" alt="image-20221205234933740"></p></li></ul><p><strong>Map中的keySet方法-返回将key值以set集合的方式返回</strong></p><p>1.Set 是java中一个存储不重复元素，且无序的集合类。<br>Map.keyset()，表示将map对象的所有key值已set集合的形式返回，因为map也是无序的，且key值也是不可重复的，因此这里用set集合存储key并返回也符合规则。</p><p>2.将Map中所有的键存入到set集合中。因为set具备迭代器。所有可以迭代方式取出所有的键，再根据get方法。获取每一个键对应的值。 keySet():迭代后只能通过get()取key。</p><p><strong>Map中的values方法-获取Map集合中的所有键值对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例  本示例创建一个Map集合对象并添加一些内容，然后调用values方法获取包含所有键值的集合对象，并输出这些键值信息。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();      <span class="comment">//定义Map集合对象</span></span><br><span class="line">    map.put(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;新鲜的苹果&quot;</span>);     <span class="comment">//向集合中添加对象</span></span><br><span class="line">    map.put(<span class="string">&quot;computer&quot;</span>, <span class="string">&quot;配置优良的计算机&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;book&quot;</span>, <span class="string">&quot;堆积成山的图书&quot;</span>);</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">values</span> <span class="operator">=</span> map.values();    <span class="comment">//获取Map集合的value集合</span></span><br><span class="line">    <span class="keyword">for</span> (Object object : values) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;键值：&quot;</span> + object.toString()); <span class="comment">//输出键值对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Map中entrySet()方法-获取到Map集合中所有的键值对对象的集合(Set集合)</strong></p><p>就是返回一个集合，集合里存放的是对象，创建对象的类有两个属性，分别是 键和值 也即<strong>键值对</strong>。<br>其中Entry是属于Map的静态内部类，在创建Map对象的时候就会同时创建一个Entry对象，用来记录键与值的映射关系。</p><p><img src="https://img-blog.csdnimg.cn/20200324133421256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY4OTE2MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapBlogTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建HashMap对象</span></span><br><span class="line">        HashMap&lt;String, String&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;键1&quot;</span>, <span class="string">&quot;值1&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;键2&quot;</span>, <span class="string">&quot;值2&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;键3&quot;</span>, <span class="string">&quot;值3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取对象的集合</span></span><br><span class="line">        Set&lt;Map.Entry&lt;String, String&gt;&gt; entries=map.entrySet();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用增强for遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; s : entries) &#123;</span><br><span class="line">            <span class="comment">//①可以直接输出 s 得到键值对</span></span><br><span class="line">            System.out.println(s);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//②也可以使用Entry类的方法 单独取出 键和值</span></span><br><span class="line">            String key=s.getKey();        <span class="comment">//获取键</span></span><br><span class="line">            String value=s.getValue();    <span class="comment">//获取值</span></span><br><span class="line">            System.out.println(key + <span class="string">&quot;=&quot;</span> + value);    <span class="comment">//输出键值</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用while用集合中的迭代器遍历</span></span><br><span class="line">        Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it=entries.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;String, String&gt; next=it.next();</span><br><span class="line">            System.out.println(next);</span><br><span class="line"></span><br><span class="line">            String key=next.getKey();        <span class="comment">//获取键</span></span><br><span class="line">            String value=next.getValue();    <span class="comment">//获取值</span></span><br><span class="line">            System.out.println(key + <span class="string">&quot;=&quot;</span> + value);    <span class="comment">//输出键值</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapSource1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;java&quot;</span>, <span class="number">10</span>);<span class="comment">//ok</span></span><br><span class="line">        map.put(<span class="string">&quot;php&quot;</span>, <span class="number">10</span>);<span class="comment">//ok</span></span><br><span class="line">        map.put(<span class="string">&quot;java&quot;</span>, <span class="number">20</span>);<span class="comment">//替换value</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;map=&quot;</span> + map);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*老韩解读HashMap的源码+图解</span></span><br><span class="line"><span class="comment">        1. 执行构造器 new HashMap()</span></span><br><span class="line"><span class="comment">           初始化加载因子 loadfactor = 0.75</span></span><br><span class="line"><span class="comment">           HashMap$Node[] table = null</span></span><br><span class="line"><span class="comment">        2. 执行put 调用 hash方法，计算 key的 hash值 (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</span></span><br><span class="line"><span class="comment">            public V put(K key, V value) &#123;//K = &quot;java&quot; value = 10</span></span><br><span class="line"><span class="comment">                return putVal(hash(key), key, value, false, true);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        3. 执行 putVal</span></span><br><span class="line"><span class="comment">         final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span></span><br><span class="line"><span class="comment">                   boolean evict) &#123;</span></span><br><span class="line"><span class="comment">                Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;//辅助变量</span></span><br><span class="line"><span class="comment">                //如果底层的table 数组为null, 或者 length =0 , 就扩容到16</span></span><br><span class="line"><span class="comment">                if ((tab = table) == null || (n = tab.length) == 0)</span></span><br><span class="line"><span class="comment">                    n = (tab = resize()).length;</span></span><br><span class="line"><span class="comment">                //取出hash值对应的table的索引位置的Node, 如果为null, 就直接把加入的k-v</span></span><br><span class="line"><span class="comment">                //, 创建成一个 Node ,加入该位置即可</span></span><br><span class="line"><span class="comment">                if ((p = tab[i = (n - 1) &amp; hash]) == null)</span></span><br><span class="line"><span class="comment">                    tab[i] = newNode(hash, key, value, null);</span></span><br><span class="line"><span class="comment">                else &#123;</span></span><br><span class="line"><span class="comment">                    Node&lt;K,V&gt; e; K k;//辅助变量</span></span><br><span class="line"><span class="comment">                // 如果table的索引位置的key的hash相同和新的key的hash值相同，</span></span><br><span class="line"><span class="comment">                 // 并 满足(table现有的结点的key和准备添加的key是同一个对象  || equals返回真)</span></span><br><span class="line"><span class="comment">                 // 就认为不能加入新的k-v</span></span><br><span class="line"><span class="comment">                    if (p.hash == hash &amp;&amp;</span></span><br><span class="line"><span class="comment">                        ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span></span><br><span class="line"><span class="comment">                        e = p;</span></span><br><span class="line"><span class="comment">                    else if (p instanceof TreeNode)//如果当前的table的已有的Node 是红黑树，就按照红黑树的方式处理</span></span><br><span class="line"><span class="comment">                        e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span></span><br><span class="line"><span class="comment">                    else &#123;</span></span><br><span class="line"><span class="comment">                        //如果找到的结点，后面是链表，就循环比较</span></span><br><span class="line"><span class="comment">                        for (int binCount = 0; ; ++binCount) &#123;//死循环</span></span><br><span class="line"><span class="comment">                            if ((e = p.next) == null) &#123;//如果整个链表，没有和他相同,就加到该链表的最后</span></span><br><span class="line"><span class="comment">                                p.next = newNode(hash, key, value, null);</span></span><br><span class="line"><span class="comment">                                //加入后，判断当前链表的个数，是否已经到8个，到8个，后</span></span><br><span class="line"><span class="comment">                                //就调用 treeifyBin 方法进行红黑树的转换</span></span><br><span class="line"><span class="comment">                                if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span></span><br><span class="line"><span class="comment">                                    treeifyBin(tab, hash);</span></span><br><span class="line"><span class="comment">                                break;</span></span><br><span class="line"><span class="comment">                            &#125;</span></span><br><span class="line"><span class="comment">                            if (e.hash == hash &amp;&amp; //如果在循环比较过程中，发现有相同,就break,就只是替换value</span></span><br><span class="line"><span class="comment">                                ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span></span><br><span class="line"><span class="comment">                                break;</span></span><br><span class="line"><span class="comment">                            p = e;</span></span><br><span class="line"><span class="comment">                        &#125;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                    if (e != null) &#123; // existing mapping for key</span></span><br><span class="line"><span class="comment">                        V oldValue = e.value;</span></span><br><span class="line"><span class="comment">                        if (!onlyIfAbsent || oldValue == null)</span></span><br><span class="line"><span class="comment">                            e.value = value; //替换，key对应value</span></span><br><span class="line"><span class="comment">                        afterNodeAccess(e);</span></span><br><span class="line"><span class="comment">                        return oldValue;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                ++modCount;//每增加一个Node ,就size++</span></span><br><span class="line"><span class="comment">                if (++size &gt; threshold[12-24-48])//如size &gt; 临界值，就扩容</span></span><br><span class="line"><span class="comment">                    resize();</span></span><br><span class="line"><span class="comment">                afterNodeInsertion(evict);</span></span><br><span class="line"><span class="comment">                return null;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">              5. 关于树化(转成红黑树)</span></span><br><span class="line"><span class="comment">              //如果table 为null ,或者大小还没有到 64，暂时不树化，而是进行扩容.</span></span><br><span class="line"><span class="comment">              //否则才会真正的树化 -&gt; 剪枝</span></span><br><span class="line"><span class="comment">              final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123;</span></span><br><span class="line"><span class="comment">                int n, index; Node&lt;K,V&gt; e;</span></span><br><span class="line"><span class="comment">                if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span></span><br><span class="line"><span class="comment">                    resize();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h4><ul><li><h4 id="注意事项和细节：-7"><a href="#注意事项和细节：-7" class="headerlink" title="注意事项和细节："></a>注意事项和细节：</h4><ol><li>存放的元素是键值对：即K-V</li><li><strong>hashtable的键和值都不能为null， 否则会抛出NulPointerException</strong></li><li>hashTable 使用方法基本上和HashMap一样</li><li>hashTable 是线程安全的(synchronized)，hashMap 是线程不安全的</li></ol></li><li><h4 id="底层机制：-2"><a href="#底层机制：-2" class="headerlink" title="底层机制："></a>底层机制：</h4><ol><li>底层有数组 Hashtable$Entry[] 初始化大小为 11</li><li>临界值 threshold 8 &#x3D; 11 * 0.75</li><li>扩容: 按照自己的扩容机制来进行即可</li><li>执行方法 addEntry(hash, key, value, index); 添加K-V 封装到Entry</li><li>当 if (count &gt;&#x3D; threshold) 满足时，就进行扩容</li><li>按照 int newCapacity &#x3D; (oldCapacity &lt;&lt; 1) + 1;的大小扩容</li></ol></li><li><h4 id="Hashtable和HashMapd"><a href="#Hashtable和HashMapd" class="headerlink" title="Hashtable和HashMapd:"></a>Hashtable和HashMapd:</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3833/%E6%88%AA%E5%B1%8F2022-05-29%2016.14.26.jpg" alt="截屏2022-05-29 16.14.26"></p></li></ul><h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><ul><li><h4 id="底层机制和源码剖析：-1"><a href="#底层机制和源码剖析：-1" class="headerlink" title="底层机制和源码剖析："></a>底层机制和源码剖析：</h4><ol><li><p>若按照compare方法比较key相同则无法加入value值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeMap_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用默认的构造器，创建TreeMap, 是字母排序</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            要求：按照传入的 k(String) 的大小进行排序</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="comment">//        TreeMap treeMap = new TreeMap();</span></span><br><span class="line">        <span class="type">TreeMap</span> <span class="variable">treeMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeMap</span>(<span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">                <span class="comment">//按照传入的 k(String) 的大小进行排序</span></span><br><span class="line">                <span class="comment">//按照K(String) 的长度大小排序</span></span><br><span class="line">                <span class="comment">//return ((String) o2).compareTo((String) o1);</span></span><br><span class="line">                <span class="keyword">return</span> ((String) o2).length() - ((String) o1).length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        treeMap.put(<span class="string">&quot;jack&quot;</span>, <span class="string">&quot;杰克&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="string">&quot;tom&quot;</span>, <span class="string">&quot;汤姆&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="string">&quot;kristina&quot;</span>, <span class="string">&quot;克瑞斯提诺&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="string">&quot;smith&quot;</span>, <span class="string">&quot;斯密斯&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="string">&quot;hsp&quot;</span>, <span class="string">&quot;韩顺平&quot;</span>);<span class="comment">//加入不了</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;treemap=&quot;</span> + treeMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            解读源码：</span></span><br><span class="line"><span class="comment">            1. 构造器. 把传入的实现了 Comparator接口的匿名内部类(对象)，传给给TreeMap的comparator</span></span><br><span class="line"><span class="comment">             public TreeMap(Comparator&lt;? super K&gt; comparator) &#123;</span></span><br><span class="line"><span class="comment">                this.comparator = comparator;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            2. 调用put方法</span></span><br><span class="line"><span class="comment">            2.1 第一次添加, 把k-v 封装到 Entry对象，放入root</span></span><br><span class="line"><span class="comment">            Entry&lt;K,V&gt; t = root;</span></span><br><span class="line"><span class="comment">            if (t == null) &#123;</span></span><br><span class="line"><span class="comment">                compare(key, key); // type (and possibly null) check</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                root = new Entry&lt;&gt;(key, value, null);</span></span><br><span class="line"><span class="comment">                size = 1;</span></span><br><span class="line"><span class="comment">                modCount++;</span></span><br><span class="line"><span class="comment">                return null;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            2.2 以后添加</span></span><br><span class="line"><span class="comment">            Comparator&lt;? super K&gt; cpr = comparator;</span></span><br><span class="line"><span class="comment">            if (cpr != null) &#123;</span></span><br><span class="line"><span class="comment">                do &#123; //遍历所有的key , 给当前key找到适当位置</span></span><br><span class="line"><span class="comment">                    parent = t;</span></span><br><span class="line"><span class="comment">                    cmp = cpr.compare(key, t.key);//动态绑定到我们的匿名内部类的compare</span></span><br><span class="line"><span class="comment">                    if (cmp &lt; 0)</span></span><br><span class="line"><span class="comment">                        t = t.left;</span></span><br><span class="line"><span class="comment">                    else if (cmp &gt; 0)</span></span><br><span class="line"><span class="comment">                        t = t.right;</span></span><br><span class="line"><span class="comment">                    else  //如果遍历过程中，发现准备添加Key 和当前已有的Key 相等，就不添加</span></span><br><span class="line"><span class="comment">                        return t.setValue(value);</span></span><br><span class="line"><span class="comment">                &#125; while (t != null);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h4 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h4><ul><li><h4 id="注意事项和细节：-8"><a href="#注意事项和细节：-8" class="headerlink" title="注意事项和细节："></a>注意事项和细节：</h4><ol><li><p>Properties类继承Hashtable类，实现了Map接口，也是使用一种简直对的形式保存数据</p></li><li><p>使用特点和Hashtable类似</p></li><li><p>Properties 还可以用于 从xxx.properties 文件中，加载数据到Properties类对象井进行读取和修改</p></li><li><p>xxx.properties 文件通常作为配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Properties_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//1. Properties 继承  Hashtable</span></span><br><span class="line">        <span class="comment">//2. 可以通过 k-v 存放数据，当然key 和 value 不能为 null</span></span><br><span class="line">        <span class="comment">//增加</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">//properties.put(null, &quot;abc&quot;);//抛出 空指针异常</span></span><br><span class="line">        <span class="comment">//properties.put(&quot;abc&quot;, null); //抛出 空指针异常</span></span><br><span class="line">        properties.put(<span class="string">&quot;john&quot;</span>, <span class="number">100</span>);<span class="comment">//k-v</span></span><br><span class="line">        properties.put(<span class="string">&quot;lucy&quot;</span>, <span class="number">100</span>);</span><br><span class="line">        properties.put(<span class="string">&quot;lic&quot;</span>, <span class="number">100</span>);</span><br><span class="line">        properties.put(<span class="string">&quot;lic&quot;</span>, <span class="number">88</span>);<span class="comment">//如果有相同的key ， value被替换</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;properties=&quot;</span> + properties);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过k 获取对应值</span></span><br><span class="line">        System.out.println(properties.get(<span class="string">&quot;lic&quot;</span>));<span class="comment">//88</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除</span></span><br><span class="line">        properties.remove(<span class="string">&quot;lic&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;properties=&quot;</span> + properties);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改</span></span><br><span class="line">        properties.put(<span class="string">&quot;john&quot;</span>, <span class="string">&quot;约翰&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;properties=&quot;</span> + properties);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h4 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h4><ul><li><h4 id="基本介绍：-5"><a href="#基本介绍：-5" class="headerlink" title="基本介绍："></a>基本介绍：</h4><ul><li>Collections 是一个操作 Set.List 和 Map 等集合的工具类</li><li>Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作</li></ul></li><li><h4 id="常用方法：-3"><a href="#常用方法：-3" class="headerlink" title="常用方法："></a>常用方法：</h4><ul><li><p>排序操作：</p><ul><li>reverse (List)：反转List中元素顺序</li><li>shuffle(List)：对 List 集合元素进行随机排序</li><li>sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序</li><li>sort(List, Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</li><li>swap (List, int,int)：将指定 list 集合中的 i处元素和j处元素进行交换</li></ul></li><li><p>查找替换：</p><ul><li><p>Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素</p></li><li><p>Object max(Collection, Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素</p></li><li><p>Object min(Collection)</p></li><li><p>Object min(Collection, Comparator)</p></li><li><p>int frequency(Collection, Object)：返回指定集合中指定元素的出现次数</p></li><li><p>void copy(List dest, List src)：将src中的内容复制到dest中</p></li><li><p>boolean replaceAll(List list, Object oldVal, Object newVal)：使用新值替换 List 对象的所有旧值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Collections_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建ArrayList 集合，用于测试.</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list.add(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;smith&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;king&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;milan&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        reverse(List)：反转 List 中元素的顺序</span></span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"><span class="comment">//        shuffle(List)：对 List 集合元素进行随机排序</span></span><br><span class="line"><span class="comment">//        for (int i = 0; i &lt; 5; i++) &#123;</span></span><br><span class="line"><span class="comment">//            Collections.shuffle(list);</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;list=&quot; + list);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序</span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(<span class="string">&quot;自然排序后&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"><span class="comment">//        sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</span></span><br><span class="line">        <span class="comment">//我们希望按照 字符串的长度大小排序</span></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">                <span class="comment">//可以加入校验代码.</span></span><br><span class="line">                <span class="keyword">return</span> ((String) o2).length() - ((String) o1).length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;字符串长度大小排序=&quot;</span> + list);</span><br><span class="line"><span class="comment">//        swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//比如</span></span><br><span class="line">        Collections.swap(list, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;交换后的情况&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;自然顺序最大元素=&quot;</span> + Collections.max(list));</span><br><span class="line">        <span class="comment">//Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素</span></span><br><span class="line">        <span class="comment">//比如，我们要返回长度最大的元素</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">maxObject</span> <span class="operator">=</span> Collections.max(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> ((String)o1).length() - ((String)o2).length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;长度最大的元素=&quot;</span> + maxObject);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Object min(Collection)</span></span><br><span class="line">        <span class="comment">//Object min(Collection，Comparator)</span></span><br><span class="line">        <span class="comment">//上面的两个方法，参考max即可</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//int frequency(Collection，Object)：返回指定集合中指定元素的出现次数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;tom出现的次数=&quot;</span> + Collections.frequency(list, <span class="string">&quot;tom&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//void copy(List dest,List src)：将src中的内容复制到dest中</span></span><br><span class="line"></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">dest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="comment">//为了完成一个完整拷贝，我们需要先给dest 赋值，大小和list.size()一样</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            dest.add(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拷贝</span></span><br><span class="line">        Collections.copy(dest, list);</span><br><span class="line">        System.out.println(<span class="string">&quot;dest=&quot;</span> + dest);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所有旧值</span></span><br><span class="line">        <span class="comment">//如果list中，有tom 就替换成 汤姆</span></span><br><span class="line">        Collections.replaceAll(list, <span class="string">&quot;tom&quot;</span>, <span class="string">&quot;汤姆&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list替换后=&quot;</span> + list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>选择集合：</p><ul><li><p>先判断存储的类型（一组对象[单列]或一组键值对[双列]）</p></li><li><p>一组对象[单列]： Collection接口</p><ul><li><p>允许重复：List</p><p>增删多：LinkedList  [底层维护双向链表]</p><p>改查多：ArrayList  [底层維护 Object类型的可变数组]</p></li><li><p>不允许重复：Set</p><p>无序：HashSet  [底层是HashMap，维护了一个哈希表，即(数组＋链表＋红黑树)]</p><p>排序：Treeset  []</p><p>插入和取出顺序一致：LinkedHashSet  [底层维护数组＋双向链表]</p></li></ul></li><li><p>一组键[值对双列]：Map</p><ul><li>键无序：HashMap  [底层是：哈希表  jdk7：数组＋链表，jdk8:数组＋链表＋红黑树]</li><li>键排序：TreeMap  []</li><li>键插入和取出顺序一致：LinkedHashMap</li><li>读取文件 Propertie</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode</title>
      <link href="/2022/12/06/LeetCode/"/>
      <url>/2022/12/06/LeetCode/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383.赎金信"></a><strong>383.赎金信</strong></h2><p>给你两个字符串：<code>ransomNote</code> 和 <code>magazine</code> ，判断 <code>ransomNote</code> 能不能由 <code>magazine</code> 里面的字符构成。<br>如果可以，返回 <code>true</code> ；否则返回 <code>false</code> 。<br><code>magazine</code> 中的每个字符只能在 <code>ransomNote</code> 中使用一次。</p><p><strong>解题思路：</strong>首先，如果 ransomNote 的长度如果大于 magazine 的长度，必然是不能构成的</p><p>其次，我们可以把 magazine 中每个字母对应在数组 cnt 的索引处，统计每个字母出现的次数（即++），然后从 ransomNote 中依次遍历取到的字母，也对应在 cnt 的索引处，统计每个字母出现的次数（即–），只要当 cnt 此次对应的数量小于0，则认为false，否则为true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(ransomNote.length() &gt; magazine.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="comment">//统计二十六个元素中对应下角标中元素出现的次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : magazine.toCharArray())&#123;</span><br><span class="line">            cnt[c-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果减去之后小于0则认为不能构成</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : ransomNote.toCharArray())&#123;</span><br><span class="line">            cnt[c-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="keyword">if</span>(cnt[c-<span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>牛客刷题笔记</title>
      <link href="/2022/12/04/%E7%89%9B%E5%AE%A2%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/12/04/%E7%89%9B%E5%AE%A2%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-类的加载"><a href="#1-类的加载" class="headerlink" title="1.类的加载"></a>1.类的加载</h3><p>类的加载括：加载，验证，准备，解析，初始化。<br>生成java.lang.Class对象：生成java.lang.Class对象是在加载时进行的。生成Class对象作为方法区这个类的各种数据的访问入口。<br>int类型对象成员变量赋予默认值：既然是对象成员，那么肯定在实例化对象后才有。在类加载的时候会赋予初值的是类变量，而非对象成员。<br>类方法解析：类方法解析发生在解析过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CharToString</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="type">char</span> <span class="variable">myChar</span> <span class="operator">=</span> <span class="string">&#x27;g&#x27;</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">myStr</span> <span class="operator">=</span> Character.toString(myChar);</span><br><span class="line">  System.out.println(<span class="string">&quot;String is: &quot;</span>+myStr);</span><br><span class="line">  myStr = String.valueOf(myChar);</span><br><span class="line">  System.out.println(<span class="string">&quot;String is: &quot;</span>+myStr);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此段代码输出的值为：</span></span><br><span class="line">String is: g</span><br><span class="line">String is: g</span><br><span class="line"><span class="comment">// 返回的都是字符串,只有char变成 int 的时候才会变为对应的assic码</span></span><br></pre></td></tr></table></figure><h3 id="2-关于抽象类和接口的叙述"><a href="#2-关于抽象类和接口的叙述" class="headerlink" title="2.关于抽象类和接口的叙述"></a>2.关于抽象类和接口的叙述</h3><p>抽象类<br>特点:<br>1.抽象类中可以构造方法<br>2.抽象类中可以存在普通属性，方法，静态属性和方法。<br>3.抽象类中可以存在抽象方法。<br>4.<strong>如果一个类中有一个抽象方法，那么当前类一定是抽象类；抽象类中不一定有抽象方法。</strong><br>5.抽象类中的抽象方法，需要有子类实现，<strong>如果子类不实现，则子类也需要定义为抽象的。</strong><br>6,<strong>抽象类不能被实例化，抽象类和抽象方法必须被abstract修饰</strong><br>关键字使用注意：<br>抽象类中的抽象方法（其前有abstract修饰）不能用private、static、synchronized、native访问修饰符修饰。</p><p>接口<br>1.在接口中只有方法的声明，没有方法体。<br>2.<strong>在接口中只有常量，因为定义的变量，在编译的时候都会默认加上public static final</strong><br>3.<strong>在接口中的方法，永远都被public来修饰</strong>。<br>4.<strong>接口中没有构造方法，也不能实例化接口的对象</strong>。（所以接口不能继承类）<br>5.接口可以实现多继承<br>6.<strong>接口中定义的方法都需要有实现类来实现，如果实现类不能实现接口中的所有方法则实现类定义为抽象类。</strong><br>7，接口可以继承接口，用extends</p><h3 id="3-内部类"><a href="#3-内部类" class="headerlink" title="3.内部类"></a>3.内部类</h3><p>在Java中，可以将一个类定义在另一个类里面或者一个方法里边，这样的类称为内部类，广泛意义上的内部类一般包括四种：成员内部类，局部内部类，匿名内部类，静态内部类 。<br>1.成员内部类<br>（1）该类像是外部类的一个成员，可以无条件的访问外部类的所有成员属性和成员方法（包括private成员和静态成员）；<br>（2）成员内部类拥有与外部类同名的成员变量时，会发生隐藏现象，即默认情况下访问的是成员内部类中的成员。如果要访问外部类中的成员，需要以下形式访问：【外部类.this.成员变量  或  外部类.this.成员方法】；<br>（3）在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问；<br>（4）成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象；<br>（5）内部类可以拥有private访问权限、protected访问权限、public访问权限及包访问权限。如果成员内部类用private修饰，则只能在外部类的内部访问；如果用public修饰，则任何地方都能访问；如果用protected修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。外部类只能被public和包访问两种权限修饰。<br>2.局部内部类<br>（1）局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内；<br>（2）局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。<br>3.匿名内部类<br>（1）一般使用匿名内部类的方法来编写事件监听代码；<br>（2）匿名内部类是不能有访问修饰符和static修饰符的；<br>（3）匿名内部类是唯一一种没有构造器的类；<br>（4）匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。<br>4.内部静态类<br>（1）静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似；<br>（2）不能使用外部类的非static成员变量或者方法。<br>下列代码运行结果是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Value</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> i=<span class="number">15</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String argv[])</span>&#123;</span><br><span class="line">        Test t=<span class="keyword">new</span> <span class="title class_">Test</span>( );</span><br><span class="line">        t.first( );</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">first</span><span class="params">( )</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">5</span>;</span><br><span class="line">    Value v=<span class="keyword">new</span> <span class="title class_">Value</span>( );</span><br><span class="line">    v.i=<span class="number">25</span>;</span><br><span class="line">    second(v,i);</span><br><span class="line">    System.out.println(v.i);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">second</span><span class="params">(Value v,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    v.i = <span class="number">20</span>;</span><br><span class="line">    <span class="type">Value</span> <span class="variable">val</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Value</span>( );</span><br><span class="line">    v = val;</span><br><span class="line">    System.out.println(v.i+<span class="string">&quot; &quot;</span>+i);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内存图如下：<br><img src="https://uploadfiles.nowcoder.com/images/20160817/6316247_1471446548929_2F9F7E31EC51C5C37F5962B0F07D6A39" alt="img"></p><h3 id="4-final、finally和finalize的区别"><a href="#4-final、finally和finalize的区别" class="headerlink" title="4.final、finally和finalize的区别"></a>4.final、finally和finalize的区别</h3><p>A，D考的一个知识点，final修饰变量，变量的引用（也就是指向的地址）不可变，但是引用的内容可以变（地址中的内容可变）。</p><p>B，finally表示总是执行。但是其实finally也有不执行的时候，但是这个题不要扣字眼。</p><ol><li><p>在try中调用System.exit(0)，强制退出了程序，finally块不执行。</p></li><li><p>在进入try块前，出现了异常，finally块不执行。</p></li></ol><p>C，finalize方法，这个选项错就错在，这个方法一个对象只能执行一次，只能在第一次进入被回收的队列，而且对象所属于的类重写了finalize方法才会被执行。第二次进入回收队列的时候，不会再执行其finalize方法，而是直接被二次标记，在下一次GC的时候被GC。</p><p>放一张图吧<br><img src="https://uploadfiles.nowcoder.com/images/20180716/3807435_1531748778229_B1F90475F3162B313B750B56294240E0" alt="img"></p><h3 id="5-Java-ThreadLocal"><a href="#5-Java-ThreadLocal" class="headerlink" title="5.Java ThreadLocal"></a>5.Java ThreadLocal</h3><p>ThreadLocal类用于创建一个线程本地变量<br>在Thread中有一个成员变量ThreadLocals，该变量的类型是ThreadLocalMap,也就是一个Map，它的键是threadLocal，值就是变量的副本，ThreadLocal为每一个使用该变量的线程都提供了一个变量值的副本，每一个线程都可以独立地改变自己的副本，是线程隔离的。通过ThreadLocal的get()方法可以获取该线程变量的本地副本，在get方法之前要先set,否则就要重写initialValue()方法。<br>ThreadLocal不是用来解决对象共享访问问题的，而主要是提供了保持对象的方法和避免参数传递的方便的对象访问方式。一般情况下，通过ThreadLocal.set() 到线程中的对象是该线程自己使用的对象，其他线程是不需要访问的，也访问不到的。各个线程中访问的是不同的对象。</p><h3 id="6-关于线程安全"><a href="#6-关于线程安全" class="headerlink" title="6.关于线程安全"></a>6.关于线程安全</h3><p>java中的线程安全是什么：<br>  就是线程同步的意思，就是当一个程序对一个线程安全的方法或者语句进行访问的时候，其他的不能再对他进行操作了，必须等到这次访问结束以后才能对这个线程安全的方法进行访问<br>  什么叫线程安全：<br>  如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。<br>  或者说:一个类或者程序所提供的接口对于线程来说是原子操作或者多个线程之间的切换不会导致该接口的执行结果存在二义性,也就是说我们不用考虑同步的问题。<br>  线程安全问题都是由全局变量及静态变量引起的。<br>  若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则就可能影响线程安全。<br> 看过vector源码的同学就会知道他的许多操作都是加了synchronized修饰的比如他的添加元素。(不知道synchronized是什么意思的自行百度！)</p><p>链接：<a href="https://www.nowcoder.com/questionTerminal/2e99a6af306247dd92c27814fe04ddb9">https://www.nowcoder.com/questionTerminal/2e99a6af306247dd92c27814fe04ddb9</a><br>来源：牛客网</p><h3 id="7-Properties"><a href="#7-Properties" class="headerlink" title="7.Properties"></a>7.Properties</h3><p>Properties继承自HashTable，  Properties中的  Store()方法把一个Properties对象的内容以一种可读的形式保存到一个文件中。Load()方法正好相反，用来读取文件，并设定Properties对象来包含keys和values。</p><p>  Properties类用来方便 的读写配置文件，支持key-value形式和xml形式的配置文件，以key-value为例，  Properties的load方法直接将文件读取到内存中并且以map形式来保存，用  getProperty(“key”)方法来取得对应的vaule值。</p><h3 id="8-java-classloader"><a href="#8-java-classloader" class="headerlink" title="8.java classloader"></a>8.java classloader</h3><p>JDK中提供了三个ClassLoader，根据层级从高到低为： </p><ol><li>Bootstrap ClassLoader，主要加载JVM自身工作需要的类。      </li><li>Extension ClassLoader，主要加载%JAVA_HOME%\lib\ext目录下的库类。</li><li>Application ClassLoader，主要加载Classpath指定的库类，一般情况下这是程序中的默认类加载器，也是<strong>ClassLoader.getSystemClassLoader()</strong> 的返回值。（这里的Classpath默认指的是环境变量中配置的Classpath，但是可以在执行Java命令的时候使用-cp 参数来修改当前程序使用的Classpath）</li></ol><p>JVM加载类的实现方式，我们称为 <strong>双亲委托模型</strong>： </p><h4 id="双亲委托模型"><a href="#双亲委托模型" class="headerlink" title="双亲委托模型"></a>双亲委托模型</h4><p>​    如果一个类加载器收到了类加载的请求，他首先不会自己去尝试加载这个类，而是把这个请求委托给自己的父加载器，每一层的类加载器都是如此，因此所有的类加载请求最终都应该传送到顶层的<strong>Bootstrap ClassLoader</strong>中，只有当父加载器反馈自己无法完成加载请求时，子加载器才会尝试自己加载。   </p><p>   <strong>双亲委托模型的重要用途是为了解决类载入过程中的安全性问题。</strong>  </p><p>   假设有一个开发者自己编写了一个名为***<a href="http://lib.csdn.net/base/java">Java</a>.lang.Object*<strong>的类，想借此欺骗JVM。现在他要使用</strong>自定义ClassLoader<strong>来加载自己编写的</strong>java.lang.Object<strong>类。然而幸运的是，</strong>双亲委托模型<strong>不会让他成功。因为JVM会优先在</strong>Bootstrap ClassLoader<strong>的路径下找到</strong><a href="http://lib.csdn.net/base/java">Java</a>.lang.Object**类，并载入它</p><p>链接：<a href="https://www.nowcoder.com/questionTerminal/7b4477d776b743fda6697ca5654fb2bc">https://www.nowcoder.com/questionTerminal/7b4477d776b743fda6697ca5654fb2bc</a><br>来源：牛客网</p><h3 id="9-HttpServletResponse接口"><a href="#9-HttpServletResponse接口" class="headerlink" title="9.HttpServletResponse接口"></a>9.HttpServletResponse接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 设置HTTP头标  </span></span><br><span class="line">response.setHeader(<span class="string">&quot;Refresh&quot;</span>,<span class="string">&quot;3&quot;</span>); <span class="comment">//三秒刷新页面一次</span></span><br><span class="line"><span class="comment">// 设置cookie</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="type">Cookie</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;only&quot;</span>);</span><br><span class="line">response.addCookie(c1);</span><br><span class="line"><span class="comment">// 读取路径信息,request读取路径信息</span></span><br><span class="line">从request获取各种路径总结</span><br><span class="line">request.getRealPath(<span class="string">&quot;url&quot;</span>); <span class="comment">// 虚拟目录映射为实际目录</span></span><br><span class="line">request.getRealPath(<span class="string">&quot;./&quot;</span>);    <span class="comment">// 网页所在的目录</span></span><br><span class="line">request.getRealPath(<span class="string">&quot;../&quot;</span>); <span class="comment">// 网页所在目录的上一层目录</span></span><br><span class="line">request.getContextPath();    <span class="comment">// 应用的web目录的名称</span></span><br><span class="line"><span class="comment">// 输出返回数据</span></span><br><span class="line">HttpServleteResponse.getOutputStream().write();</span><br><span class="line"><span class="comment">/*链接：https://www.nowcoder.com/questionTerminal/caf1a6034fde47388c94cc27cd803a37</span></span><br><span class="line"><span class="comment">来源：牛客网*/</span></span><br></pre></td></tr></table></figure><h3 id="10-单例模式的六种实现方式"><a href="#10-单例模式的六种实现方式" class="headerlink" title="10.单例模式的六种实现方式"></a>10.单例模式的六种实现方式</h3><p>话不多说直接上链接:<a href="https://www.nowcoder.com/questionTerminal/c329b173a9b34cb1af6165395b8e7635">六种单例实现</a></p><h3 id="11-函数中定义的变量，存储单元为什么在内存的栈区"><a href="#11-函数中定义的变量，存储单元为什么在内存的栈区" class="headerlink" title="11.函数中定义的变量，存储单元为什么在内存的栈区"></a>11.函数中定义的变量，存储单元为什么在内存的栈区</h3><p>首先说明栈内存和堆内存里存放的是什么 </p><ul><li>栈内存中存放函数中定义的一些基本类型的变量和对象的引用变量；  </li><li>堆内存中存放new创建的对象和数组。</li></ul><p>  简单的来说，堆主要是用来存放对象的，栈主要是用来执行程序的 </p><p>  这么做是因为 </p><ul><li>栈的存取速度快，栈数据可以共享，但是栈中的数据大小和生存期必须确定，缺乏灵活性中存放一些基本类型的对象和对象句柄  </li><li>堆是操作系统分配给自己内存，由于从操作系统管理的内存分配，所以再分配和销毁时都需要占用时间，因此用堆的效率非常低，但是优点在于编译器不需要指导从堆里分配多少存储控件，也不需要知道存储的数据要再堆里停留多长事件，因此用堆保存数据时会得到更大的灵活性</li></ul><p><a href="https://www.nowcoder.com/questionTerminal/86fccbe7141848c6a99f4a95de9cb7be">参考链接</a></p><h3 id="12-Java线程转换状态图"><a href="#12-Java线程转换状态图" class="headerlink" title="12.Java线程转换状态图"></a>12.Java线程转换状态图</h3><p><img src="https://pic.imgdb.cn/item/63934f8db1fccdcd365d9365.png"></p><h3 id="13-什么是存根类-Stub"><a href="#13-什么是存根类-Stub" class="headerlink" title="13.什么是存根类 Stub"></a>13.什么是存根类 Stub</h3><p>存根类是一个类，它实现了一个接口，但是实现后的每个方法都是空的。</p><p>它的作用是：如果一个接口有很多方法，如果要实现这个接口，就要实现所有的方法。但是一个类从业务来说，可能只需要其中一两个方法。如果直接去实现这个接口，除了实现所需的方法，还要实现其他所有的无关方法。而如果通过继承存根类就实现接口，就免去了这种麻烦</p><p>14.String对象的两种创建方式</p><p>第一种方式: String str1 &#x3D; “aaa”; 是在常量池中获取对象(“aaa” 属于字符串字面量，因此编译时期会在常量池中创建一个字符串对象)，</p><p>第二种方式: String str2 &#x3D; new String(“aaa”) ; 一共会创建两个字符串对象一个在堆中，一个在常量池中（前提是常量池中还没有 “aaa” 字符串对象）。</p><p>System.out.println(str1&#x3D;&#x3D;str2);&#x2F;&#x2F;false</p><p>2.String类型的常量池比较特殊。它的主要使用方法有两种：<br>直接使用双引号声明出来的String对象会直接存储在常量池中。<br>如果不是用双引号声明的String对象,可以使用 String 提供的 intern 方法。 String.intern() 是一个 Native 方法，它的作用是： 如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用； 如果没有，则在常量池中创建与此 String 内容相同的字符串，<em>并返回常量池中创建的字符串的引用</em>。<br>String s1 &#x3D; new String(“AAA”);<br>String s2 &#x3D; s1.intern();<br>String s3 &#x3D; “AAA”;<br>System.out.println(s2);&#x2F;&#x2F;AAA<br>System.out.println(s1 &#x3D;&#x3D; s2);&#x2F;&#x2F;false，因为一个是堆内存中的String对象一个是常量池中的String对象，<br>System.out.println(s2 &#x3D;&#x3D; s3);&#x2F;&#x2F;true， s2,s3指向常量池中的”AAA“</p><p><a href="https://www.nowcoder.com/questionTerminal/644933ebcb814fc3a99c8533b8ac6301">String对象的两种创建方式，牛客网原题</a></p><h3 id="14-垃圾回收机制"><a href="#14-垃圾回收机制" class="headerlink" title="14.垃圾回收机制"></a>14.垃圾回收机制</h3><p>java提供了一个系统级的线程，即垃圾回收器线程。用来对每一个分配出去的内存空间进行跟踪。当JVM空闲时，自动回收每块可能被回收的内存，GC是完全自动的，不能被强制执行。程序员最多只能用System.gc()来建议执行垃圾回收器回收内存，但是具体的回收时间，是不可知的。当对象的引用变量被赋值为null，可能被当成垃圾。</p><p>链接：<a href="https://www.nowcoder.com/questionTerminal/4650487daf784a0bbffdeb523dd536b5">https://www.nowcoder.com/questionTerminal/4650487daf784a0bbffdeb523dd536b5</a><br>来源：牛客网</p><h3 id="15-socket编程中，以下哪个socket的操作是不属于服务端操作的（）？"><a href="#15-socket编程中，以下哪个socket的操作是不属于服务端操作的（）？" class="headerlink" title="15.socket编程中，以下哪个socket的操作是不属于服务端操作的（）？"></a>15.socket编程中，以下哪个socket的操作是不属于服务端操作的（）？</h3><p><img src="https://c2.im5i.com/2022/12/11/RNezG.png" alt="RNezG.png"></p><p>TCP客户端：</p><p>1.建立连接套接字，设置Ip和端口监听，socket()</p><p>2.建立连接 connect</p><p>3.write() 获取网络流对象 发送数据</p><p>4.read()获取网络流对象 接收数据</p><p>5.关闭套接字</p><p>TCP服务器端</p><p>1.建立端口监听 socket()</p><p>2.绑定指定端口 bind()</p><p>3.listen 进行端口监听</p><p>4.accept() 阻塞式 直到有客户端访问</p><p>5.read()获取客户端发送数据</p><p>6.write()发送返回数据</p><p>7.close关闭端口监听</p><p><a href="https://www.nowcoder.com/questionTerminal/38fb0886232b42b6a542c288d256eee1">点击跳转到原题</a></p><h3 id="16-下列哪些操作会使线程释放锁资源？"><a href="#16-下列哪些操作会使线程释放锁资源？" class="headerlink" title="16.下列哪些操作会使线程释放锁资源？"></a>16.下列哪些操作会使线程释放锁资源？</h3><h4 id="1-sleep-方法"><a href="#1-sleep-方法" class="headerlink" title="1.sleep()方法"></a><strong>1.sleep()方法</strong></h4><p>在指定时间内让当前正在执行的线程暂停执行，但不会释放“锁标志”。不推荐使用。</p><p>sleep()使当前线程进入阻塞状态，在指定时间内不会执行。</p><h4 id="2-wait-方法"><a href="#2-wait-方法" class="headerlink" title="2.wait()方法"></a><strong>2.wait()方法</strong></h4><p>在其他线程调用对象的notify或notifyAll方法前，导致当前线程等待。线程会释放掉它所占有的“锁标志”，从而使别的线程有机会抢占该锁。</p><p>当前线程必须拥有当前对象锁。如果当前线程不是此锁的拥有者，会抛出IllegalMonitorStateException异常。</p><p>唤醒当前对象锁的等待线程使用notify或notifyAll方法，也必须拥有相同的对象锁，否则也会抛出IllegalMonitorStateException异常。</p><p>waite()和notify()必须在synchronized函数或synchronized　block中进行调用。如果在non-synchronized函数或non-synchronized　block中进行调用，虽然能编译通过，但在运行时会发生IllegalMonitorStateException的异常。</p><h4 id="3-yield方法"><a href="#3-yield方法" class="headerlink" title="3.yield方法"></a><strong>3.yield方法</strong></h4><p>暂停当前正在执行的线程对象。</p><p>yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。</p><p>yield()只能使同优先级或更高优先级的线程有执行的机会。</p><h4 id="4-join方法"><a href="#4-join方法" class="headerlink" title="4.join方法"></a><strong>4.join方法</strong></h4><p>等待该线程终止。</p><p>等待调用join方法的线程结束，再继续执行。如：t.join();&#x2F;&#x2F;主要用于等待t线程运行结束，若无此句，main则会执行完毕，导致结果不可预测。</p><p><a href="https://www.nowcoder.com/questionTerminal/3a3f308d61d0453e91ccc23bd6aff468">原题请点击这里</a></p><h3 id="17-关于运行时常量池，下列哪个说法是正确的"><a href="#17-关于运行时常量池，下列哪个说法是正确的" class="headerlink" title="17.关于运行时常量池，下列哪个说法是正确的"></a>17.关于运行时常量池，下列哪个说法是正确的</h3><p><strong>方法区是什么？</strong></p><p>方法区是广义上的概念，是一个定义、标准，可以理解为Java中的接口，在Jdk6、7方法区的实现叫永久代；Jdk8之后方法区的实现叫元空间，并从JVM内存中移除，放到了直接内存中；<br>方法区是被所有方法线程共享的一块内存区域.</p><p><strong>运行时常量池是什么？</strong></p><p>运行时常量池是每一个类或接口的常量池的运行时表示形式.</p><p>具体体现就是在Java编译后生成的.class文件中，会有class常量池，也就是静态的运行时常量池；</p><p><strong>运行时常量池存放的位置？</strong></p><p>运行时常量池一直是方法区的一部分，在不同版本的JDK中，由于方法区位置的变化，运行时常量池所处的位置也不一样.JDK1.7及之前方法区位于永久代.由于一些原因在JDK1.8之后彻底祛除了永久代,用元空间代替。</p><p><strong>运行时常量池存放什么？</strong></p><p>存放编译期生成的各种字面量和符号引用；（字面量和符号引用不懂的同学请自行查阅）<br>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。 此时不再是常量池中的符号地址了，这里换为真实地址。</p><p>运行时常量池与字符串常量池？（可能有同学把他俩搞混）<br>字符串常量池：在JVM中，为了减少相同的字符串的重复创建，为了达到节省内存的目的。会单独开辟一块内存，用于保存字符串常量，这个内存区域被叫做字符串常量池.</p><p><strong>字符串常量池位置？</strong></p><p>JDK1.6时字符串常量池，被存放在方法区中（永久代），而到了JDK1.7，因为永久代垃圾回收频率低；而字符串使用频率比较高，不能及时回收字符串，会导致导致永久代内存不足，就被移动到了堆内存中。</p><p>[原题请戳这里](<a href="https://www.nowcoder.com/questionTerminal/1c6207fead8f4189b3980c3fed2d36ae">https://www.nowcoder.com/questionTerminal/1c6207fead8f4189b3980c3fed2d36ae</a><br>来源：牛客网)</p><h3 id="18-如果希望监听TCP端口9000，服务器端应该怎样创建socket"><a href="#18-如果希望监听TCP端口9000，服务器端应该怎样创建socket" class="headerlink" title="18.如果希望监听TCP端口9000，服务器端应该怎样创建socket?"></a>18.如果希望监听TCP端口9000，服务器端应该怎样创建socket?</h3><p>ServerSocket(int port) 是服务端绑定port端口，调accept()监听等待客户端连接，它返回一个连接队列中的一个socket。</p><p>Socket(InetAddress address ,      int port)是创建客户端连接主机的socket流，其中InetAddress是用来记录主机的类，port指定端口。</p><p><a href="https://www.nowcoder.com/questionTerminal/ab05758aa3064056973daa0fb6722fca">原题戳这里</a></p><p>19.以下说法错误的是（） [有关泛型]</p><p>1、创建泛型对象的时候，一定要指出类型变量T的具体类型。争取让编译器检查出错误，而不是留给JVM运行的时候抛出类不匹配的异常。 2、JVM如何理解泛型概念 —— 类型擦除。事实上，JVM并不知道泛型，所有的泛型在编译阶段就已经被处理成了普通类和方法。 处理方法很简单，我们叫做类型变量T的擦除(erased) 。</p><p>总结：泛型代码与JVM</p><ol><li>虚拟机中没有泛型，只有普通类和方法。</li><li>在编译阶段，所有泛型类的类型参数都会被Object或者它们的限定边界来替换。(类型擦除)</li><li>在继承泛型类型的时候，桥方法的合成是为了避免类型变量擦除所带来的多态灾难。     无论我们如何定义一个泛型类型，相应的都会有一个原始类型被自动提供。原始类型的名字就是擦除类型参数的泛型类型的名字。</li></ol><p><a href="https://cloudimge.com/image/RG0Nq"><img src="https://c2.im5i.com/2022/12/12/RG0Nq.png" alt="RG0Nq.png"></a></p><h3 id="20-以下关于对象序列化描述正确的是"><a href="#20-以下关于对象序列化描述正确的是" class="headerlink" title="20.以下关于对象序列化描述正确的是"></a>20.以下关于对象序列化描述正确的是</h3><p><img src="https://c2.im5i.com/2022/12/12/RGams.png" alt="RGams.png"></p><p><a href="https://cloudimge.com/image/RGphQ"><img src="https://c2.im5i.com/2022/12/12/RGphQ.png" alt="RGphQ.png"></a></p><p><a href="https://cloudimge.com/image/RG7B3"><img src="https://c2.im5i.com/2022/12/12/RG7B3.png" alt="RG7B3.png"></a></p><h1 id="21-检查程序，是否存在问题，如果存在指出问题所在，如果不存在，说明输出结果。"><a href="#21-检查程序，是否存在问题，如果存在指出问题所在，如果不存在，说明输出结果。" class="headerlink" title="21.检查程序，是否存在问题，如果存在指出问题所在，如果不存在，说明输出结果。"></a>21.检查程序，是否存在问题，如果存在指出问题所在，如果不存在，说明输出结果。</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> algorithms.com.guan.javajicu; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inc</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">       <span class="type">Inc</span> <span class="variable">inc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inc</span>(); </span><br><span class="line">       <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">       inc.fermin(i); </span><br><span class="line">       i= i ++; </span><br><span class="line">       System.out.println(i);</span><br><span class="line">    </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fermin</span><span class="params">(<span class="type">int</span> i)</span>&#123; </span><br><span class="line">       i++; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么输出的是i &#x3D; 0，而不是 i &#x3D; 1？</p><p>原因：jvm里面有两个存储区，一个是暂存区（是一个堆栈，以下称为堆栈），另一个是变量区。jvm会这样运行这条语句，JVM把count值（其值是0）拷贝到临时变量区。        步骤2　count值加1，这时候count的值是1。 步骤3　返回临时变量区的值，注意这个值是0，没修改过。 步骤4　返回值赋值给count，此时count值被重置成0。</p><p><a href="https://www.nowcoder.com/questionTerminal/b507628f3f0b4c85a00a7ed0de830413">了解详细？戳这里之间跳转</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">(牛客网) Wrysunny201710302106264 的讲解比较简单明了(初学者也可以看懂)，如有不对的地方请各路大神指点。</span></span><br><span class="line"><span class="comment">i++      先赋值在计算结果；</span></span><br><span class="line"><span class="comment">++i      先计算结果再赋值。</span></span><br><span class="line"><span class="comment">int i = 0;  </span></span><br><span class="line"><span class="comment">       i = i ++;  // 左边这个i其实是障眼法，就是一个中间变量，可以和下行的i合并；</span></span><br><span class="line"><span class="comment">       System.out.println(i);   这里等价于:</span></span><br><span class="line"><span class="comment">int i = 0;</span></span><br><span class="line"><span class="comment">       System.out.println(i++);   这下再看，先赋值(先将i传给println函数打印出来,在计算表达式结果)</span></span><br><span class="line"><span class="comment">所以打印出来的是0，实际上整个表达式的结果已经是1了，只是没有打印出整个表达式的结果。</span></span><br><span class="line"><span class="comment">所以我们知道如下结论：</span></span><br><span class="line"><span class="comment">1、无论怎么变，i++和++i的整个表达式的结果都是1.</span></span><br><span class="line"><span class="comment">2、有时我们打印的是表达式的结果(System.out.println(++i)),</span></span><br><span class="line"><span class="comment">   有时我们打印的只是一个中间变量(System.out.println(i++))。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">i++;</span><br><span class="line">System.out.println(i);  <span class="comment">//值为1    打印的是表达式的结果</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">++i;</span><br><span class="line">System.out.println(i);  <span class="comment">//值为1     打印的是表达式的结果 </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">i = i++;</span><br><span class="line">System.out.println(i);  <span class="comment">//值为0      打印的是中间变量(JVM中间缓存变量机制)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">i = ++i;</span><br><span class="line">System.out.println(i);  <span class="comment">//值为1    打印的是表达式的结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">链接：https://www.nowcoder.com/questionTerminal/b507628f3f0b4c85a00a7ed0de830413</span></span><br><span class="line"><span class="comment">来源：牛客网</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="22-在Java语言中，下列关于字符集编码（Character-set-encoding）和国际化（i18n）的问题，哪些是正确的？"><a href="#22-在Java语言中，下列关于字符集编码（Character-set-encoding）和国际化（i18n）的问题，哪些是正确的？" class="headerlink" title="22.在Java语言中，下列关于字符集编码（Character set encoding）和国际化（i18n）的问题，哪些是正确的？"></a>22.在Java语言中，下列关于字符集编码（Character set encoding）和国际化（i18n）的问题，哪些是正确的？</h1><p>A 显然是错误的，Java一律采用Unicode编码方式，每个字符无论中文还是英文字符都占用2个字节。</p><p>B 也是不正确的，不同的编码之间是可以转换的，通常流程如下： 将字符串S以其自身编码方式分解为字节数组，再将字节数组以你想要输出的编码方式重新编码为字符串。 例：String newUTF8Str &#x3D; new String(oldGBKStr.getBytes(“GBK”), “UTF8”);</p><p>C 是正确的。Java虚拟机中通常使用UTF-16的方式保存一个字符</p><p>D 也是正确的。ResourceBundle能够依据Local的不同，选择性的读取与Local对应后缀的properties文件，以达到国际化的目的。</p><p>综上所述，答案是  C 和 D。</p><p><a href="https://www.nowcoder.com/questionTerminal/20766232d1eb45c5a37457953438f133">更多解答请戳这里</a></p><h1 id="23-下面程序运行完之后，t2与t3的关系为（）"><a href="#23-下面程序运行完之后，t2与t3的关系为（）" class="headerlink" title="23.下面程序运行完之后，t2与t3的关系为（）"></a>23.下面程序运行完之后，t2与t3的关系为（）</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Object obj=<span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">List aList=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">List bList=<span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line"> </span><br><span class="line"><span class="type">long</span> t1=System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50000</span>;i++)&#123;</span><br><span class="line">    aList.add(<span class="number">0</span>,obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> t2=System.currentTimeMillis()-t1;</span><br><span class="line"> </span><br><span class="line">t1=System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50000</span>;i++)&#123;</span><br><span class="line">    bList.add(<span class="number">0</span>,obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> t3=System.currentTimeMillis()-t1; </span><br></pre></td></tr></table></figure><p>解析：<a href="https://www.nowcoder.com/questionTerminal/22a15ba9381845e9b225e9d393d5c028">原题戳这里</a></p><p>LinkedList每次增加的时候，会new 一个Node对象来存新增加的元素，所以当数据量小的时候，这个时间并不明显，而ArrayList需要扩容，所以LinkedList的效率就会比较高，但当ArrayList不需要扩容的时候它的效率应该是比LinkedList高的，当数据量很大达到千万级别的时候，new对象的时间大于扩容的时间，那么就会出现ArrayList的效率比Linkedlist高的情况了。题目中的数据量并没有大到这种程度，因此扩容所需时间依然大于new 一个Node对象的时间，因此选项D正确。</p><p>​    另外，有同学疑惑一直在index&#x3D;0的位置插入数据为什么会增加空间，这是因为add(index,value) index &#x3D; 0 这种头插法会将原有数值向后推，覆盖值应使用set(index,value)方法。</p><p>链接：<a href="https://www.nowcoder.com/questionTerminal/22a15ba9381845e9b225e9d393d5c028">https://www.nowcoder.com/questionTerminal/22a15ba9381845e9b225e9d393d5c028</a><br>来源：牛客网</p><p><strong>ArrayList：增删慢，查询快。</strong></p><p>由于是数据组实现，需要连续的内存空间，如果删除数组中间的值，为了保证下标的有效性，需要将后面的数据往前移，所以删除慢。</p><p>当插入A对象到B对象的前面时，需要将B对象和B对象之后的所有对象后移一位，再插入A对象。所以插入慢。</p><p>数组的大小是固定的，如果数组满了，需要重新分配空间，new一个新数组并copy旧数据之后再增加新数据，所以增加慢。</p><p>因为是连续内存空间，可以通过下标查询数据，所以查询快。</p><p><strong>LInkedList：增删快，查询慢。</strong></p><p>由于是链表实现，当前节点的next指向下一个节点，prev指向上一个节点，不需要连续的内存空间，所以增删快。</p><p>因为不是连续内存空间，所以不能使用下标查询，只能通过next遍历，所以查询慢。</p><h1 id="24-下面关于依赖注入-DI-的说法不正确的是-A"><a href="#24-下面关于依赖注入-DI-的说法不正确的是-A" class="headerlink" title="24.下面关于依赖注入(DI)的说法不正确的是(A)"></a>24.下面关于依赖注入(DI)的说法不正确的是(A)</h1><p>A. 只有通过Spring才能实现依赖注入(DI)</p><p>B. 依赖注入的主要目的是解耦合</p><p>C. 常见的依赖注入方式有Setter和构造方法</p><p>Spring依赖注入（DI）的三种方式，分别为：</p><p>1． 接口注入</p><p>2． Setter 方法注入</p><p>3． 构造方法注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">属性注入：</span></span><br><span class="line"><span class="comment">创建对象时候,向类里面属性里面设置值</span></span><br><span class="line"><span class="comment">注入的三种方式（java），在Spring框架中只支持前面两种方式</span></span><br><span class="line"><span class="comment">第一种：使用set方法注入</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">User user=<span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setName(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">第二种：有参数构造注入</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">User user=<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;lucy&quot;</span>);</span><br><span class="line">第三种：使用接口注入</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Dao</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaoImplements</span> Dao&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用有参数构造注入属性</span><br><span class="line">&lt;bean id=<span class="string">&quot;demo&quot;</span> class=<span class="string">&quot;cn.itcast.property.propertyDemo1&quot;</span>&gt;</span><br><span class="line">    &lt;constructor-arg name=<span class="string">&quot;username&quot;</span> value=<span class="string">&quot;小王小马&quot;</span>&gt;&lt;/constructor&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestIOC</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="number">1.</span>加载Spring配置文件，根据创建对象</span><br><span class="line">        APPlicationContext context=<span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean1.xml&quot;</span>)</span><br><span class="line">        <span class="number">2.</span>得到配置创建的对象</span><br><span class="line">        PropertyDemo1 demo1=(PropertyDemo1)context.getBean(<span class="string">&quot;demo&quot;</span>);</span><br><span class="line">        demo1.test1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用set方法注入属性(使用的更多)</span><br><span class="line">&lt;bean id=<span class="string">&quot;book&quot;</span> class=<span class="string">&quot;cn.itcast.property.Book&quot;</span>&gt;  <span class="comment">//代表对象已经创建</span></span><br><span class="line"><span class="comment">//name属性值：类里面定义的属性名称 value属性：设置具体的值</span></span><br><span class="line">    &lt;property name=<span class="string">&quot;bookname&quot;</span> vlaue=<span class="string">&quot;易筋经&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String bookname;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String bookname)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.bookname=bookname;</span><br><span class="line">    &#125;</span><br><span class="line">    pubic <span class="keyword">void</span> <span class="title function_">demobook</span><span class="params">()</span>&#123;</span><br><span class="line">        system.out.println(<span class="string">&quot;book........&quot;</span>+bookname);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestIOC</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="number">1.</span>加载Spring配置文件，根据创建对象</span><br><span class="line">        APPlicationContext context=<span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean1.xml&quot;</span>)</span><br><span class="line">        <span class="number">2.</span>得到配置创建的对象</span><br><span class="line">        Book book=(Book)context.getBean(<span class="string">&quot;book&quot;</span>);</span><br><span class="line">        book.demobook();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">链接：https://www.nowcoder.com/questionTerminal/27be162a9c774c30a735ecdd3b5f57a5</span></span><br><span class="line"><span class="comment">来源：牛客网</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="25-类方法中可以直接调用对象变量？"><a href="#25-类方法中可以直接调用对象变量？" class="headerlink" title="25.类方法中可以直接调用对象变量？"></a>25.类方法中可以直接调用对象变量？</h1><ul><li>静态方法中不能调用对象的变量，因为静态方法在类加载时就初始化，对象变量需要在新建对象后才能使用</li><li>类方法&#x3D;类的静态方法 类变量&#x3D;类的静态变量 对象方法&#x3D;类的非静态方法 对象变量&#x3D;类的非静态变量 所以static方法调用非静态变量不行，必须初始化对象之后调用</li></ul><h1 id="26-如果要导入一个java-scut-computer的包，叙述正确的是？"><a href="#26-如果要导入一个java-scut-computer的包，叙述正确的是？" class="headerlink" title="26.如果要导入一个java.scut.computer的包，叙述正确的是？  ( )"></a>26.如果要导入一个java.scut.computer的包，叙述正确的是？  ( )</h1><p><a href="https://www.nowcoder.com/questionTerminal/c70fa69d5c0f4f09b7553d4f84bed281">原题戳这里</a></p><p>实际上在Java语言规范中，不允许package name以“java”开头，不然会报一个java.lang.SecurityException 的错误。因为假如我们允许包名以java开头，那么我们完全可以编写和jdk标准包下一模一样的类，如Java.lang.Integer。因此在虚拟机进行类或接口解析时可能会发生冲突。一句话总结就是:假如允许包名以java开头，可能会导致命名空间污染的问题。实际上Java对此也做了限制，具体的源码解析可以参考这篇博客–<a href="http://www.jianshu.com/p/f9a56a3edadd">http://www.jianshu.com/p/f9a56a3edadd</a></p><h1 id="27-mvc模式设计的web应用程序的优点"><a href="#27-mvc模式设计的web应用程序的优点" class="headerlink" title="27.mvc模式设计的web应用程序的优点"></a>27.mvc模式设计的web应用程序的优点</h1><p>链接：<a href="https://www.nowcoder.com/questionTerminal/940d9dd9a582442090b42443f8883f5e">https://www.nowcoder.com/questionTerminal/940d9dd9a582442090b42443f8883f5e</a><br>来源：牛客网</p><p>MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面</p><p>显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。</p><p>MVC只是将分管不同功能的逻辑代码进行了隔离，增强了可维护和可扩展性，增强代码复用性，因此可以减少代码重复。但是不保证减少代码量，多层次的调用模式还有可能增加代码量</p><p><img src="https://pic.imgdb.cn/item/639996eab1fccdcd365f3ba1.jpg"></p><h1 id="28-线程join"><a href="#28-线程join" class="headerlink" title="28.线程join"></a>28.线程join</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">下列代码执行结果为（）</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span><span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">      Thread t=<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">          &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.print(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      t.start();</span><br><span class="line">      </span><br><span class="line">      t.join();</span><br><span class="line">      System.out.print(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">解析：因为子线程的休眠时间太长，因此主线程很有可能在子线程之前结束也就是输出结果是12，但是子线程用了join函数，因此主线程必须等待子线程执行完毕才结束因此输出结果只能是21</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="29-JavaWEB中有一个类，当会话种绑定了属性或者删除了属性时，他会得到通知，这个类是："><a href="#29-JavaWEB中有一个类，当会话种绑定了属性或者删除了属性时，他会得到通知，这个类是：" class="headerlink" title="29.JavaWEB中有一个类，当会话种绑定了属性或者删除了属性时，他会得到通知，这个类是：(  )"></a>29.JavaWEB中有一个类，当会话种绑定了属性或者删除了属性时，他会得到通知，这个类是：(  )</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A.HttpSessionAttributeListener</span><br><span class="line">B.HttpSessionBindingListener</span><br><span class="line">C.HttpSessionObjectListener</span><br><span class="line">D.HttpSessionListener;</span><br><span class="line">E.HttpSession</span><br><span class="line">F.HttpSessionActivationListener</span><br></pre></td></tr></table></figure><p>链接：<a href="https://www.nowcoder.com/questionTerminal/12aa0298fb874408b93485e1bf52be44">https://www.nowcoder.com/questionTerminal/12aa0298fb874408b93485e1bf52be44</a><br>来源：牛客网</p><p><strong>HttpSessionAttributeListener</strong>：可以实现此侦听器接口获取此web应用程序中会话属性列表更改的通知；</p><p><strong>HttpSessionBindingListener</strong>：当该对象从一个会话中被绑定或者解绑时通知该对象，这个对象由HttpSessionBindingEvent对象通知。这可能是servlet程序显式地从会话中解绑定属性的结果，可能是由于会话无效，也可能是由于会话超时；</p><p><strong>HttpSessionObjectListener</strong>：没有该接口API；</p><p><strong>HttpSessionListener</strong>：当web应用程序中的活动会话列表发生更改时通知该接口的实现类，为了接收该通知事件，必须在web应用程序的部署描述符中配置实现类；</p><p><strong>HttpSessionActivationListener</strong>：绑定到会话的对象可以侦听容器事件，通知它们会话将被钝化，会话将被激活。需要一个在虚拟机之间迁移会话或持久会话的容器来通知所有绑定到实现该接口会话的属性。</p><h1 id="30-CMS垃圾回收器在那些阶段是没用用户线程参与的"><a href="#30-CMS垃圾回收器在那些阶段是没用用户线程参与的" class="headerlink" title="30.CMS垃圾回收器在那些阶段是没用用户线程参与的"></a>30.CMS垃圾回收器在那些阶段是没用用户线程参与的</h1><p>CMS收集器是一种以获取最短回收停顿时间为目标的收集器，它是基于标记清除算法实现的，它的运作过程相对于其他收集器来说要更复杂一些，整个过程分为四个步骤，包括：初始标记、并发标记、重新标记、并发清除。其中初始标记、重新标记这两个步骤需要暂停整个JVM。</p><ol><li>​    初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快。</li><li>​    并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</li><li>​    重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</li><li>​    并发清除阶段，清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。</li></ol><p>示意图如下：</p><p><img src="https://pic.imgdb.cn/item/6399a9bfb1fccdcd368269af.jpg"></p><p>链接：<a href="https://www.nowcoder.com/questionTerminal/48ee199608824e409cca879ae50e6022">https://www.nowcoder.com/questionTerminal/48ee199608824e409cca879ae50e6022</a><br>来源：牛客网</p><h1 id="31-下面哪个Set类是按元素排好序的？-B"><a href="#31-下面哪个Set类是按元素排好序的？-B" class="headerlink" title="31.下面哪个Set类是按元素排好序的？(B)"></a>31.下面哪个Set类是按元素排好序的？(B)</h1><p>A. LinkedHashSet</p><p>B. TreeSet</p><p>C.HashSet</p><p>D. AbstractSet</p><p>如果向TreeSet里面添加自定义类型的元素，那么自然规则是什么呢？其实本质是：添加进TreeSet中的元素都指定了排序规则，有两种指定方式，要么 元素实现java.lang.Comparable接口，要么创建TreeSet的时候传入一个java.util.Comparator类型的比较器。一般我们往TreeSet中添加的数字、字符串等类型的元素，都是用的第一种方式，sun公司在定义的这些类都实现了java.lang.Comparable，这就是所谓的自然规则。而如果需要向TreeSet中添加自定义类型的元素，也必须指定排序规则(两种方式都可以)，否则在进行添加的时候会报错(一个非受检异常java.lang.ClassCastException)。</p><p>链接：<a href="https://www.nowcoder.com/questionTerminal/73d50ca606c640a68016bfa4ed2aec00">https://www.nowcoder.com/questionTerminal/73d50ca606c640a68016bfa4ed2aec00</a><br>来源：牛客网</p><p><a href="https://blog.csdn.net/ailaohuyou211/article/details/125429279">更多内容TreeSet详解</a></p><h1 id="32-JDK提供的用于并发编程的同步器有哪些？"><a href="#32-JDK提供的用于并发编程的同步器有哪些？" class="headerlink" title="32.JDK提供的用于并发编程的同步器有哪些？"></a>32.JDK提供的用于并发编程的同步器有哪些？</h1><p>A. Semaphore</p><p>B. CyclicBarrier</p><p>C. CountDownLatch</p><p>D. Counter</p><p>答案：ABC</p><p>A，Java 并发库 的Semaphore 可以很轻松完成信号量控制，Semaphore可以控制某个资源可被同时访问的个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。</p><p>B，CyclicBarrier 主要的方法就是一个：await()。await() 方法没被调用一次，计数便会减少1，并阻塞住当前线程。当计数减至0时，阻塞解除，所有在此 CyclicBarrier 上面阻塞的线程开始运行。</p><p>C，直译过来就是倒计数(CountDown)门闩(Latch)。倒计数不用说，门闩的意思顾名思义就是阻止前进。在这里就是指 CountDownLatch.await() 方法在倒计数为0之前会阻塞当前线程。</p><p>D，Counter不是并发编程的同步器</p><p>链接：<a href="https://www.nowcoder.com/questionTerminal/6a670710f1a54892985575aa4dd67cdc">https://www.nowcoder.com/questionTerminal/6a670710f1a54892985575aa4dd67cdc</a><br>来源：牛客网</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
